var tunepad = (function (exports, Prism) {
    'use strict';

    const stylesheet$b = new CSSStyleSheet();
    stylesheet$b.replaceSync(`/*
@keyframes fade-out {
    0% {
        opacity: 1.0;
    }

    100% {
        opacity: 0.0;
    }
}
*/
.instrument {
    position: relative;
    box-sizing: border-box;
    display: flex;
}

.backdrop {
    fill: #30303f;
}

.container {
    width: 100%;
}

.piano-key.black {
    fill: #1d1e1f;
    stroke: #222;
    stroke-width: 1.5;
    rx: 1.5;
}

.piano-key.black .black-top {
    fill: #444;
}

.piano-key.black:hover .black-top {
    fill: #777;
}

.piano-key.black.pressed .black-top {
    fill: #222;
}

.piano-key.white {
    fill: #ecedee;
    stroke: #f7f7f8;
    stroke-width: 1.5;
    rx: 1.4;
}

.piano-key.white:hover {
    fill: #ccc;
}

.piano-key.white.pressed {
    fill: #aaa;
    stroke: #777;
}
/*
.piano-key.white.pressed.step-0 { fill: rgb(229, 76, 78); }
.piano-key.white.pressed.step-2 { fill: rgb(228, 171, 81); }
.piano-key.white.pressed.step-4 { fill: rgb(223, 228, 78); }
.piano-key.white.pressed.step-5 { fill: rgb(174, 215, 71); }
.piano-key.white.pressed.step-7 { fill: rgb(63, 169, 180); }
.piano-key.white.pressed.step-9 { fill: rgb(78, 69, 179); }
.piano-key.white.pressed.step-11 { fill: rgb(202, 69, 147); }
*/
.note-hint,
.midi-hint,
.key-hint {
    stroke: none;
    font: 9pt sans-serif;
    fill: #0006;
    text-anchor: middle;
    opacity: 0.0;
    pointer-events: none;
    user-select: none;
}

.midi-hint.black, .note-hint.black, .key-hint.black {
    fill: #ccc;
}
.show {
    opacity: 1.0;
}

.note-hint.always-show {
    opacity: 1.0;
}

.felt {
    fill: #a00;
}

.animated-slide {
    transition: transform 0.5s ease-in-out;
}

.mini-piano {
    opacity: 0.0;
    transition: opacity 0.25s;
}

.mini-piano.show {
    opacity: 1.0;
}
`);

    var html$8 = "<div class=\"instrument\"><svg class=\"container\" version=\"1.1\"></svg></div>";

    const MEDefaults = {
        note: 0,
        velocity: 90,
        message: "note-on",
        source: "pointer"
    };
    /**
     * MIDI event class
     */
    class MIDIEvent {
        get customEvent() {
            return new CustomEvent(this.props.message, {
                bubbles: true,
                composed: true,
                detail: this.props
            });
        }
        constructor(props) {
            this.props = { ...MEDefaults, ...props, ...{ time: Date.now() } };
        }
    }
    /**
     * Singleton wrapper around javascript's MIDIAccess
     */
    class MIDIManager {
        /**
         * Singleton instance initializer. Can safely be called multiple times.
         */
        static init() {
            if (!MIDIManager.instance) {
                MIDIManager.instance = new MIDIManager();
            }
        }
        /**
         * Is the MIDI access object ready?
         */
        static get ready() {
            MIDIManager.init();
            return (MIDIManager.instance?.access !== undefined);
        }
        static get outputs() {
            MIDIManager.init();
            return MIDIManager.instance ? MIDIManager.instance._outputs : undefined;
        }
        get _outputs() {
            return this.access ? this.access.outputs : undefined;
        }
        static get inputs() {
            MIDIManager.init();
            return MIDIManager.instance ? MIDIManager.instance._inputs : undefined;
        }
        get _inputs() {
            return this.access ? this.access.inputs : undefined;
        }
        constructor() {
            navigator.requestMIDIAccess().then((midi) => {
                this.access = midi;
                console.log("Connected to MIDI.");
                midi.addEventListener("statechange", (e) => this._midiConnection(e));
                //for (let input of midi.inputs.values()) {
                //    input.onmidimessage = _midiEvent;
                //}
                midi.outputs.forEach((out) => out.open());
            }, () => { console.log("Failed to initialize web MIDI."); });
        }
        /**
         * Fired when midi devices are added or removed.
         */
        _midiConnection(event) {
            const e = event;
            const port = e.port; // MIDIPort
            if (port) {
                if (port.type == "input" && port.state == "connected") {
                    port.onmidimessage = this._midiEvent;
                }
                else if (port.type == "output" && port.state == "connected") {
                    port.open();
                }
            }
        }
        /**
         * Processes incoming midi events and send it to listeners
         */
        _midiEvent(event) {
            if (event.data && event.data.length >= 2) {
                let cmd = event.data[0] >> 4;
                let channel = event.data[0] & 0xf;
                let note = event.data[1];
                let velocity = 0;
                if (event.data.length >= 3)
                    velocity = event.data[2];
                console.log(cmd, channel, note, velocity);
                // FIXME : callback or listener dist
            }
        }
    }

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    class PianoKeyboard extends HTMLElement {
        get minKey() { return this.props.minOctave * 12 + 12; }
        get maxKey() { return this.props.maxOctave * 12 + 23; }
        constructor() {
            super();
            /// attribute set
            this.props = {
                noteHints: true,
                midiHints: true,
                armed: false,
                minOctave: 0,
                maxOctave: 7,
                keyRange: 24,
                focusOctave: 2
            };
            /// <svg> tag that contains the instrument
            this.container = null;
            /// group that contains all of the visual elements
            this.parent = document.createElementNS("http://www.w3.org/2000/svg", 'g');
            /// group that contains all the keys
            this.allKeys = document.createElementNS("http://www.w3.org/2000/svg", 'g');
            /// array of piano keys
            this.keys = [];
            /// size of the containing element
            this.width = 700;
            this.height = 190;
            /// mini piano that shows where we are left-to-right
            //late MiniPiano mini;
            /// mapping from computer keys to piano keys
            this.key_map = "awsedftgyhujkolp;']";
            this.root = this.attachShadow({ mode: 'open' });
            this.root.adoptedStyleSheets.push(stylesheet$b);
            //this.mini = MiniPiano(this);
        }
        connectedCallback() {
            const template = document.createElement('template');
            template.innerHTML = html$8;
            // Create a shadow root
            this.root.appendChild(template.content.cloneNode(true));
            // load the container <svg> element from the shadow dom
            this.container = this.root.querySelector("svg.container");
            this.container?.append(this.parent);
            this.container?.setAttribute('viewBox', `0 0 ${this.props.keyRange * PianoKey.width} 190`);
            // render SVG content
            this.render();
            // listen to keyboard events
            document.addEventListener("keydown", e => this.onKeyDown(e));
            document.addEventListener("keyup", e => this.onKeyUp(e));
        }
        disconnectedCallback() {
            //console.log("Custom element removed from page.");
        }
        attributeChangedCallback(name, oldValue, newValue) {
            switch (name) {
                case 'note-hints':
                    this.setNoteHints(newValue != "false");
                    break;
                case 'midi-hints':
                    this.setMidiHints(newValue != "false");
                    break;
                case 'armed':
                    (newValue == "false") ? this.disarmKeyboard() : this.armKeyboard();
                    break;
                case 'key-range':
                    this.setKeyRange(parseInt(newValue));
                    break;
                case 'min-octave':
                    this.setMinOctave(parseInt(newValue));
                    break;
                case 'max-octave':
                    this.setMaxOctave(parseInt(newValue));
                    break;
                case 'focus-octave':
                    this.setFocusOctave(parseInt(newValue));
                    break;
            }
        }
        /**
         * Add note events to the event stream
         */
        emitNoteOn(note, source, velocity = 90) {
            const e = new MIDIEvent({ note, source, velocity, message: "note-on" });
            this.root.host.dispatchEvent(e.customEvent);
        }
        emitNoteOff(note, source) {
            const e = new MIDIEvent({ note, source, velocity: 0, message: "note-off" });
            this.root.host.dispatchEvent(e.customEvent);
        }
        emitPitchBend(value, source) {
            const e = new MIDIEvent({ value, source, message: "pitch-bend" });
            this.root.host.dispatchEvent(e.customEvent);
        }
        /**
         * Show note being played
         */
        noteOn(note, velocity = 90) {
            let key = this._noteToKey(note);
            key?.press();
        }
        /**
         * Hide note being played
         */
        noteOff(note) {
            let key = this._noteToKey(note);
            key?.release();
        }
        allNotesOff() {
            this.keys.forEach((key) => key.release());
        }
        /**
         * Is note currently pressed?
        */
        isNoteOn(note) {
            let key = this._noteToKey(note);
            return (key != null && key.isPressed());
        }
        /**
         * How many white keys to show at one time
         */
        setKeyRange(count) {
            if (!isNaN(count)) {
                this.props.keyRange = Math.max(7, Math.min(count, 56));
                this.container?.setAttribute('viewBox', `0 0 ${this.props.keyRange * PianoKey.width} 190`);
            }
        }
        setMinOctave(octave) {
            if (isNaN(octave))
                return;
            octave = Math.max(0, Math.min(6, octave));
            if (octave != this.props.minOctave) {
                this.props.minOctave = octave;
                this.render();
            }
        }
        setMaxOctave(octave) {
            if (isNaN(octave))
                return;
            octave = Math.max(1, Math.min(7, octave));
            if (octave != this.props.maxOctave) {
                this.props.maxOctave = octave;
                this.render();
            }
        }
        /**
         * Should the piano respond to keyboard events?
         */
        armKeyboard() {
            this.props.armed = true;
            this.root.querySelectorAll(".key-hint").forEach(e => { e.classList.add("show"); });
        }
        disarmKeyboard() {
            this.props.armed = false;
            this.root.querySelectorAll(".key-hint").forEach(e => { e.classList.remove("show"); });
        }
        get isKeyboardArmed() { return this.props.armed; }
        getArmedKey(char) {
            const fi = (this.props.focusOctave - this.props.minOctave) * 12;
            const ki = this.key_map.indexOf(char.toLowerCase());
            return (ki >= 0 && ki + fi < this.keys.length) ? this.keys[ki + fi] : null;
        }
        /**
         * Process a computer key down event ... possibly play a note
         */
        onKeyDown(e) {
            if (e.ctrlKey || e.metaKey || e.shiftKey || e.repeat == true)
                return;
            if (this.isKeyboardArmed) {
                const key = this.getArmedKey(e.key.toLowerCase());
                if (key) {
                    this.emitNoteOn(key.note, "keyboard");
                    key.press();
                }
                else if (e.key == "ArrowLeft") {
                    this.setFocusOctave(this.props.focusOctave - 1);
                }
                else if (e.key == "ArrowRight") {
                    this.setFocusOctave(this.props.focusOctave + 1);
                }
                else if (e.key == "ArrowDown") {
                    this.emitPitchBend(-200, "keyboard");
                }
                else if (e.key == "ArrowUp") {
                    this.emitPitchBend(200, "keyboard");
                }
            }
        }
        /**
         * Process a computer key up event ... possibly release a note
         */
        onKeyUp(e) {
            if (e.key == "ArrowUp" || e.key == "ArrowDown") {
                this.emitPitchBend(0, "keyboard");
            }
            else {
                const key = this.getArmedKey(e.key.toLowerCase());
                if (key) {
                    this.emitNoteOff(key.note, "keyboard");
                    key.release();
                }
            }
        }
        /**
         * Convert a midi note to piano key number
         */
        _noteToKey(midi) {
            const index = Math.round(midi - 12);
            return (index >= 0 && index >= this.keys.length) ? this.keys[index] : null;
        }
        render() {
            if (this.container == null)
                return; // only render once mounted
            this.parent.innerHTML = "";
            this.keys = [];
            const backdrop = document.createElementNS("http://www.w3.org/2000/svg", 'rect');
            backdrop.classList.add("backdrop");
            backdrop.setAttribute("width", "100%");
            backdrop.setAttribute("height", "100%");
            this.parent.append(backdrop);
            this.allKeys.classList.add("animated-slide");
            const whiteKeys = document.createElementNS("http://www.w3.org/2000/svg", 'g');
            const blackKeys = document.createElementNS("http://www.w3.org/2000/svg", 'g');
            // generate piano keys
            for (let i = this.minKey; i <= this.maxKey; i++) {
                const key = new PianoKey(i, this);
                this.keys.push(key);
                if (key.black) {
                    blackKeys.append(key.el);
                }
                else {
                    whiteKeys.append(key.el);
                }
            }
            this.allKeys.append(whiteKeys);
            this.allKeys.append(blackKeys);
            this.parent.append(this.allKeys);
            /*
                    const shelf = document.createElementNS("http://www.w3.org/2000/svg", 'rect');
                    shelf.setAttribute("width", "100%");
                    shelf.setAttribute("height", "6");
                    shelf.setAttribute("x", "0");
                    shelf.setAttribute("y", "1");
                    shelf.setAttribute("fill", "black");
                    shelf.setAttribute("fill-opacity", "0.2");
                    this.parent.append(shelf);
            */
            const felt = document.createElementNS("http://www.w3.org/2000/svg", 'rect');
            felt.classList.add("felt");
            felt.setAttribute("width", "100%");
            felt.setAttribute("height", "1.5");
            felt.setAttribute("x", "0");
            felt.setAttribute("y", "0");
            this.parent.append(felt);
            // set up minified piano
            //this.mini.render();
            this.setFocusOctave(this.props.focusOctave);
            //this.mini.hide();
            //this.parent.append(mini.el);
        }
        setFocusOctave(octave) {
            this.props.focusOctave = Math.max(this.props.minOctave, Math.min(this.props.maxOctave, octave));
            const focusIndex = (this.props.focusOctave - this.props.minOctave) * 12;
            if (isNaN(octave) || this.container == null)
                return;
            this.keys.forEach((key) => key.autoRelease());
            if (focusIndex >= 0 && focusIndex < this.keys.length) {
                const dx = this.keys[focusIndex].x;
                this.allKeys.style.transform = `translateX(${-dx}px)`;
                // update keyboard hints
                this.keys.forEach((key) => key.clearKeymap());
                for (let i = 0; i < this.key_map.length; i++) {
                    const index = focusIndex + i;
                    if (index >= 0 && index < this.keys.length) {
                        this.keys[index].setKeymap(this.key_map[i]);
                    }
                }
                //this.mini.show();
                //this.mini.slide(dx);
            }
        }
        /**
         * Show note name hints
         */
        setNoteHints(on) {
            this.props.noteHints = on;
            this.root.querySelectorAll(".note-hint").forEach(e => { e.classList.toggle("show", on); });
        }
        get showNoteHints() { return this.props.noteHints; }
        /**
         * Show midi number hints
         */
        setMidiHints(on) {
            this.props.midiHints = on;
            this.root.querySelectorAll(".midi-hint").forEach(e => { e.classList.toggle("show", on); });
        }
        get showMidiHints() { return this.props.midiHints; }
    }
    PianoKeyboard.observedAttributes = [
        "note-hints", // show note names ("true" | "false")
        "midi-hints", // show midi note numbers ("true" | "false")
        "armed", // accepts keyboard input ("true" | "false")
        "min-octave", // lowest octave (0)
        "max-octave", // highest key (7)
        "key-range", // how many keys to show at one time
        "focus-octave" // left-most octave showing
    ];
    PianoKeyboard.ELEMENT = "piano-keyboard";
    /**
     * Represents a black or white key on the piano keyboard
     */
    class PianoKey {
        /// half step value (0 - 12)
        get step() { return this.note % 12; }
        /// note octave
        get octave() { return Math.floor(this.note / 12) - 1; }
        /// note name
        get name() { return `${PianoKey.NOTES[this.step]}`; }
        /// index x-coordinate on the keyboard
        get offset() {
            const oct = this.octave - this.piano.props.minOctave;
            return oct * 7 + this._key_offsets[this.step];
        }
        /// pixel x-coordinate on the keyboard
        get x() { return this.offset * PianoKey.width; }
        /// is this a black key or white key?
        get black() { return [1, 3, 6, 8, 10].includes(this.step); }
        /// is this a white key
        get white() { return !this.black; }
        /// height of key
        get height() { return this.black ? 130 : 195; }
        constructor(note, piano) {
            /// key map hint
            this.keyHint = document.createElementNS("http://www.w3.org/2000/svg", 'text');
            /// key offset arrangement starting with C
            /// this helps us render black keys at off-center positions
            this._key_offsets = [0, 0.45, 1, 1.55, 2, 3, 3.4, 4, 4.5, 5, 5.6, 6];
            this._hint_offsets = [-8, 0, 0, 0, +8, -8, 0, 0, 0, 0, 0, +8];
            /// visual element for SVG
            this.el = document.createElementNS("http://www.w3.org/2000/svg", 'g');
            /// main key rectangle
            this.rect = document.createElementNS("http://www.w3.org/2000/svg", 'rect');
            /// is the key currently pressed?
            this._down = false;
            this.note = note;
            this.piano = piano;
            this.el.setAttribute("transform", `translate(${this.x}, 0)`);
            this.el.classList.add("piano-key", `step-${this.step}`);
            this.el.classList.add(this.black ? "black" : "white");
            const pad = this.black ? 10 : 1.5;
            let x0 = pad;
            let w = PianoKey.width - (pad * 2);
            this.rect.setAttribute("x", `${x0}`);
            this.rect.setAttribute("y", "-8");
            this.rect.setAttribute("width", `${w}`);
            this.rect.setAttribute("height", `${this.height}`);
            this.rect.setAttribute("rx", "3");
            this.el.append(this.rect);
            if (this.black) {
                x0 += 3;
                w -= 6;
                const r = document.createElementNS("http://www.w3.org/2000/svg", 'rect');
                r.classList.add("black-top");
                r.setAttribute("x", `${x0}`);
                r.setAttribute("y", "-5");
                r.setAttribute("width", `${w}`);
                r.setAttribute("height", `${this.height - 20}`);
                r.setAttribute("pointer-events", "none");
                this.el.append(r);
            }
            else {
                const noteHint = document.createElementNS("http://www.w3.org/2000/svg", 'text');
                noteHint.classList.add("note-hint");
                noteHint.setAttribute("x", `${x0 + w / 2}`);
                noteHint.setAttribute("y", `${this.height - 17}`);
                noteHint.innerHTML = `${this.name}${this.octave}`;
                if (this.piano.showNoteHints)
                    noteHint.classList.add("show");
                // always show C notes
                if (this.step == 0)
                    noteHint.classList.add('always-show');
                this.el.append(noteHint);
            }
            const midiHint = document.createElementNS("http://www.w3.org/2000/svg", 'text');
            midiHint.classList.add("midi-hint");
            if (this.black)
                midiHint.classList.add("black");
            midiHint.setAttribute("x", `${x0 + w / 2}`);
            midiHint.setAttribute("y", `${this.height - 35}`);
            midiHint.innerHTML = `${this.note}`;
            if (this.piano.showMidiHints)
                midiHint.classList.add("show");
            this.el.append(midiHint);
            let hx = x0 + w / 2 + this._hint_offsets[this.step];
            this.keyHint.classList.add("key-hint");
            if (this.black)
                this.keyHint.classList.add("black");
            this.keyHint.setAttribute("x", `${hx}`);
            this.keyHint.setAttribute("y", this.black ? "45" : "60");
            //this.keyHint.setAttribute("y", `${this.height - 57}`);
            if (this.piano.isKeyboardArmed)
                this.keyHint.classList.add("show");
            this.el.append(this.keyHint);
            // set up mouse events
            this.el.addEventListener('pointerdown', (e) => {
                this.piano.emitNoteOn(this.note, "pointer");
                this.press();
                e.stopPropagation();
            });
            this.el.addEventListener('pointerup', (e) => {
                this.piano.emitNoteOff(this.note, "pointer");
                this.release();
            });
            this.el.addEventListener('pointerleave', (e) => {
                if (this._down) {
                    this.piano.emitNoteOff(this.note, "pointer");
                    this.release();
                }
            });
            this.el.addEventListener('pointerenter', (e) => {
                if (e.buttons > 0) {
                    this.piano.emitNoteOn(this.note, "pointer");
                    this.press();
                }
            });
        }
        press() {
            this._down = true;
            this.el.classList.add("pressed");
        }
        release() {
            if (this._down) {
                this._down = false;
                this.el.classList.remove("pressed");
            }
        }
        isPressed() {
            return this.el.classList.contains("pressed");
        }
        autoRelease() {
            if (this._down) {
                this.piano.emitNoteOff(this.note, "system");
                this._down = false;
                this.el.classList.remove("pressed");
            }
        }
        setKeymap(k) {
            this.keyHint.innerHTML = k;
        }
        clearKeymap() {
            this.keyHint.innerHTML = "";
        }
    }
    /// musical notes (in half steps) in the 12-note chromatic scale
    PianoKey.NOTES = ["C", "C♯", "D", "D♯", "E", "F", "F♯", "G", "G♯", "A", "A♯", "B"];
    /// pixel width of white key (in SVG coords system)
    PianoKey.width = 45;

    const stylesheet$a = new CSSStyleSheet();
    stylesheet$a.replaceSync(`
.piano-wrapper {
    width: 100%;
    margin: 0 auto;
    border-radius: 10px;
    display: flex;
}

piano-keyboard { flex: 1; }
.octave-button {
    background-color: transparent;
    border: none;
    outline: none;
    color: #fffc;
    font-size: 14px;
    user-select: none;
    width: 12px;
    padding: 0;
}
.octave-button:hover { color: #fff; }
.octave-button:active { color: rgb(121, 216, 245); }
`);

    var html$7 = "<div class=\"piano-wrapper\">\n    <button id=\"down-octave\" class=\"octave-button\" title=\"Lower Octave\">❮</button>\n    <piano-keyboard note-hints=\"true\" midi-hints=\"true\" armed=\"true\" max-octave=\"8\" min-octave=\"1\" focus-octave=\"3\" key-range=\"14\"></piano-keyboard>\n    <button id=\"up-octave\" class=\"octave-button\" title=\"Higher Octave\">❯</button>\n</div>";

    /**
     * Parses an int from an object (usually a string)
     * @param d - The input value to be parsed
     * @param defaultValue - The default value to return if the parsing fails
     * @returns The parsed integer value
     */
    function toInt(d, defaultValue = 0) {
        const n = parseInt(d);
        return isNaN(n) ? defaultValue : n;
    }
    /**
     * Parses a number from an object (usually a string)
     * @param d - The input value to be parsed
     * @param defaultValue - The default value to return if the parsing fails
     * @returns The parsed number value
     */
    function toNum(d, defaultValue = 0) {
        const n = parseFloat(d);
        return isNaN(n) ? defaultValue : n;
    }
    /**
     * Parses a DateTime object from an int representing milliseconds since the epoch.
     * Returns DateTime.now() as a default value.
     * @param d - The input value to be parsed
     * @returns The parsed DateTime object
     */
    function toDateTime(d) {
        return Date.parse(d);
    }
    /**
     * Formats a DateTime object as a string
     * @param d - The DateTime object to be formatted
     * @returns The formatted date and time string
     */
    /*
    function formatDateTime(d: DateTime): string {
        const months = ['', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const date = `${months[d.month]} ${d.day}, ${d.year}`;
        let h = d.hour % 12;
        if (h === 0) h = 12;
        const time = `${h}:${d.minute.toString().padStart(2, '0')}${d.hour < 12 ? 'AM' : 'PM'}`;
        return `${date} ${time}`;
    }
    */
    /**
     * Parses a boolean value from an object (usually a string or boolean)
     * @param b - The input value to be parsed
     * @param defaultValue - The default value to return if the parsing fails
     * @returns The parsed boolean value
     */
    function toBool(b, defaultValue = false) {
        if (b == null) {
            return defaultValue;
        }
        else if (typeof b === 'boolean') {
            return b;
        }
        else {
            const s = b.toString().toLowerCase();
            if (s === 'true' || s === 't') {
                return true;
            }
            else if (s === 'false' || s === 'f') {
                return false;
            }
        }
        return defaultValue;
    }
    /**
     * Converts a value to a string
     * @param o - The input value to be converted
     * @param defaultValue - The default value to return if the conversion fails
     * @returns The converted string value
     */
    function toStr(o, defaultValue = '') {
        return (!o) ? defaultValue : o.toString();
    }
    /**
     * Linearly interpolates between two values
     * @param a - The starting value
     * @param b - The ending value
     * @param interp - The interpolation factor (between 0 and 1)
     * @returns The interpolated value
     */
    function mix(a, b, interp) {
        return a + interp * (b - a);
    }
    /**
     * Converts a decibel value to a gain value
     * @param dB - The decibel value
     * @returns The gain value
     */
    function dBToGain(dB) {
        return Math.max(0.0, Math.pow(10, dB / 20));
    }
    /**
     * Converts a gain value to a decibel value
     * @param gain - The gain value
     * @returns The decibel value
     */
    function gainTodB(gain) {
        return 20 * Math.log(gain) / Math.LN10;
    }
    /**
     * Converts a decibel value to a value
     * @param dB - The decibel value
     * @returns The value
     */
    function dBToValue(dB) {
        return Math.pow(10, dB / 20) / 1.78;
    }
    /**
     * Converts a gain value to a value
     * @param gain - The gain value
     * @returns The value
     */
    function gainToValue(gain) {
        return dBToValue(gainTodB(gain));
    }
    /**
     * Converts a value to a decibel value
     * @param value - The value
     * @returns The decibel value
     */
    function valueTodB(value) {
        return 20 * Math.log(1.78 * value) / Math.LN10;
    }
    /**
     * Converts a value to a gain value
     * @param value - The value
     * @returns The gain value
     */
    function valueToGain(value) {
        return dBToGain(valueTodB(value));
    }
    /**
     * Converts a velocity value to a gain value
     * @param velocity - The velocity value (0-127)
     * @returns The gain value
     */
    function veloctyToGain(velocity) {
        return valueToGain(velocity / 127.0);
    }
    function clamp$1(val, minV, maxV) {
        return Math.max(minV, Math.min(maxV, val));
    }

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    /**
     * Thin wrapper around the audio context timer that lets you set time
     * and synchronize multiple subscribers playing at the same time.
     */
    class TunePadAudio {
        get bpm() { return this._bpm; }
        set bpm(tempo) { this.setTempo(tempo); }
        get meter() { return this._meter; }
        set meter(m) { this.setTimeSignature(m); }
        get beatsPerMeasure() { return this._beatsPerMeasure; }
        get beatValue() { return this._beatValue; }
        get key() { return this._key; }
        set key(keyName) { this._key = keyName; }
        /// current time of the audio context
        get contextTime() { return this.context.currentTime; }
        /// elapsed time in seconds since we last called play
        get time() { return (this.isPaused) ? this._start : this.contextTime - this._start; }
        /// elapsed time as hh:mm:ss string
        get timeString() {
            let m = `${Math.floor(this.time / 60) % 60}`;
            let s = `${Math.round(this.time) % 60}`;
            let c = `${Math.floor(this.time * 100) % 100}`;
            if (m.length == 1)
                m = `0${m}`;
            if (s.length == 1)
                s = `0${s}`;
            if (c.length == 1)
                c = `0${c}`;
            return `${m}:${s}.${c}`;
        }
        /// elapsed time in beats
        get beats() { return (this.time * this.bpm / 60) + this._elapsedBeats; }
        /// is the clock paused?
        get isPaused() { return this._subscribers.size == 0; }
        /// init the singleton instance and start the audio engine
        /// ok to call this method more than once.
        static init() {
            if (TunePadAudio._instance == null) {
                TunePadAudio._instance = new TunePadAudio();
            }
            return TunePadAudio._instance;
        }
        constructor() {
            /// time at which clock was last started or paused
            this._start = 0;
            /// subscribers can set the time to an arbitrary beat
            this._elapsedBeats = 0;
            /// common beats per minute for all subscribers to the clock
            this._bpm = 90;
            /// time signature
            this._meter = "4/4";
            /// beats per measure
            this._beatsPerMeasure = 4;
            /// denominator of the time signature (e.g. 4, 2, 8...)
            this._beatValue = 4; // quarter note is the default
            /// musical key
            this._key = "C major";
            /// list of current subscribers to the clock that are currently playing
            this._subscribers = new Set();
            /// list of all subscribers for global events such as time signature changes
            this._listeners = new Set();
            /// underlying implementation uses the audio context timer
            this.context = new AudioContext();
            /// list of subscribed metronomes
            this._metronomes = new Set();
            this._timer = -1;
        }
        addSubscriber(subscriber) {
            this._listeners.add(subscriber);
        }
        removeSubscriber(subscriber) {
            this._listeners.delete(subscriber);
        }
        isPlaying(subscriber) {
            return this._subscribers.has(subscriber);
        }
        /**
         * Start playing for this subscriber
         */
        play(subscriber) {
            if (this.isPaused) {
                this._start = this.contextTime - this._start;
            }
            this._subscribers.add(subscriber);
            this._listeners.add(subscriber);
        }
        /**
         * Pause this subscriber only ...
         */
        pause(subscriber) {
            this._listeners.add(subscriber);
            if (this.isPlaying(subscriber)) {
                this._subscribers.delete(subscriber);
                if (this.isPaused) {
                    this._start = (this.contextTime - this._start);
                }
            }
        }
        /**
         * Reset the clock back to zero beats and stop all subscribers
         */
        stopAll() {
            this._elapsedBeats = 0;
            this._start = 0;
            this._subscribers.clear();
            this._listeners.forEach(s => s.onClockReset());
        }
        /**
         * Automatically stops all subscribers
         */
        setTime(elapsedBeats) {
            this._elapsedBeats = elapsedBeats;
            this._start = 0;
            this._listeners.forEach(s => s.onClockTimeChange());
            this._subscribers.clear();
        }
        setTempo(tempo) {
            if (isNaN(tempo))
                return;
            const lastBeats = this.beats;
            if (tempo != this._bpm) {
                this._bpm = Math.max(5, tempo);
                this._start = this.contextTime - lastBeats * 60 / this._bpm;
                this._listeners.forEach((s) => s.onTempoChange());
            }
        }
        setTimeSignature(s) {
            // sanity check the time signature string
            if (s.split('/').length != 2)
                s = "4/4";
            this._beatsPerMeasure = toInt(s.split('/')[0], -1);
            this._beatValue = toInt(s.split('/')[1], -1);
            if (this._beatsPerMeasure < 0 || this._beatValue < 0) {
                this._beatsPerMeasure = 4;
                this._beatValue = 4;
            }
            const newMeter = `${this._beatsPerMeasure}/${this._beatValue}`;
            if (this._meter != newMeter) {
                this._meter = newMeter;
                this._listeners.forEach(s => s.onTimeSignatureChange());
            }
        }
        startMetronome(metronome) {
            this._metronomes.add(metronome);
            if (this._timer == -1) {
                const start_time = this.contextTime;
                let beat = 0;
                this._metronomes.forEach(m => m.pulse(0));
                this._timer = window.setInterval(() => {
                    if (this._metronomes.size == 0) {
                        window.clearInterval(this._timer);
                        this._timer = -1;
                    }
                    else {
                        const beat_len = 60 / this.bpm;
                        const elapsed = (this.contextTime - start_time);
                        const b = Math.floor(elapsed / beat_len) % this.beatsPerMeasure;
                        if (b != beat) {
                            beat = b;
                            this._metronomes.forEach(m => m.pulse(beat));
                        }
                    }
                }, 30);
            }
        }
        stopMetronome(metronome) {
            this._metronomes.delete(metronome);
        }
        isMetronomePlaying(metronome) {
            return this._metronomes.has(metronome);
        }
    }

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    /**
     * Thin wrapper around the AudioBuffer class that allows for
     * exporting to WAV, MP3, and Base64. Also generates compressed waveform visualization data.
     * This is *mostly* an immutable object, except for the append operation, which can grow the buffer.
     */
    class GrowableAudioBuffer {
        getChannelData(channel) { return this.channels[channel]; }
        // channel count
        get numberOfChannels() { return this.channels.length; } // mono = 1, stereo = 2
        // length of the audio in samples
        get samples() { return this.channels[0].length; }
        get length() { return this.channels[0].length; }
        // is the audio buffer empty
        get isEmpty() { return this.samples <= 0; }
        // length of the audio in seconds
        get duration() { return this.samples / this.sampleRate; }
        // mono or stereo?
        get isMono() { return this.channels.length === 1; }
        get isStereo() { return this.channels.length === 2; }
        /**
         * Create a new empty buffer with the given number of channels and sample rate
         */
        constructor(channels = 1, sampleRate = 44100) {
            this.channels = new Array();
            this.sampleRate = sampleRate;
            for (let i = 0; i < channels; i++) {
                this.channels.push(new Float32Array());
            }
        }
        /**
         * Append the given audio data to this buffer and return the new buffer.
         * This is the only function that mutates the GrowableAudioBuffer.
         * @returns Returns this object with the new audio data appended.
         */
        appendAudioBuffer(buffer) {
            if (buffer.sampleRate !== this.sampleRate) {
                throw "Cannot append to GrowableAudioBuffer due to a sample rate mismatch.";
            }
            const appended = new Array();
            for (let c = 0; c < this.numberOfChannels; c++) {
                const dest = new Float32Array(this.channels[c].length + buffer.length);
                const src = buffer.getChannelData(c < buffer.numberOfChannels ? c : 0);
                dest.set(this.channels[c], 0);
                dest.set(src, this.channels[c].length);
                appended.push(dest);
            }
            this.channels = appended;
            return this;
        }
        append(buffer) {
            if (buffer.sampleRate !== this.sampleRate) {
                throw "Cannot append to GrowableAudioBuffer due to a sample rate mismatch.";
            }
            const appended = new Array();
            for (let c = 0; c < this.numberOfChannels; c++) {
                const dest = new Float32Array(this.samples + buffer.samples);
                const src = buffer.channels[c < buffer.numberOfChannels ? c : 0];
                dest.set(this.channels[c], 0);
                dest.set(src, this.channels[c].length);
                appended.push(dest);
            }
            this.channels = appended;
            return this;
        }
        /**
         * Create a new buffer from the given AudioBuffer object
         */
        static fromBuffer(buffer) {
            const gab = new GrowableAudioBuffer(buffer.numberOfChannels, buffer.sampleRate);
            return gab.appendAudioBuffer(buffer);
        }
        /**
         * load audio source from a URL. Throws an error if buffer cannot be loaded.
         */
        static async fromURL(url) {
            const context = TunePadAudio.init().context;
            const response = await fetch(url);
            const abuff = await response.arrayBuffer();
            const buffer = await context.decodeAudioData(abuff);
            return GrowableAudioBuffer.fromBuffer(buffer);
        }
        /**
         * Create a copy of this buffer
         */
        clone() {
            const gab = new GrowableAudioBuffer(this.numberOfChannels, this.sampleRate);
            const cloned = new Array();
            for (let c = 0; c < gab.numberOfChannels; c++) {
                cloned.push(new Float32Array(this.channels[c]));
            }
            gab.channels = cloned;
            return gab;
        }
        /**
         * Trim the buffer from a start to an end point in seconds.
         * Return the new buffer.
         */
        trim(start, end) {
            const A = clamp$1(Math.round(start * this.sampleRate), 0, this.samples - 1);
            const B = clamp$1(Math.round(end * this.sampleRate), 0, this.samples - 1);
            const len = B - A;
            const gab = new GrowableAudioBuffer(this.numberOfChannels, this.sampleRate);
            if (len <= 0 || this.isEmpty) {
                return gab;
            }
            // copy in trimmed data
            const trimmed = new Array();
            for (let c = 0; c < this.numberOfChannels; c++) {
                trimmed.push(this.channels[c].slice(A, B));
            }
            gab.channels = trimmed;
            return gab;
        }
        /**
         * reverses the audio and returns the new buffer
         */
        reverse() {
            const samples = this.samples;
            const reversed = new Array();
            for (let c = 0; c < this.numberOfChannels; c++) {
                reversed.push(new Float32Array(samples));
                let j = samples - 1;
                for (let i = 0; i < samples; i++) {
                    reversed[c][j] = this.channels[c][i];
                    j--;
                }
            }
            const gab = new GrowableAudioBuffer(this.numberOfChannels, this.sampleRate);
            gab.channels = reversed;
            return gab;
        }
        /**
         * create an AudioBuffer from the saved audio data.
         * The length of the buffer must be greater than zero or this will throw an exception.
         */
        toAudioBuffer() {
            if (this.buffer)
                return this.buffer;
            this.buffer = new AudioBuffer({
                "length": this.samples,
                "numberOfChannels": this.numberOfChannels,
                "sampleRate": this.sampleRate
            });
            for (let c = 0; c < this.numberOfChannels; c++) {
                this.buffer.copyToChannel(this.channels[c], c);
            }
            return this.buffer;
        }
        /// encodes the audio buffer as an MP3 byte array
        /*
        Uint8List? toMP3() {
            if (_buffer == null) toAudioBuffer();
            if (_buffer == null) return null;

            // only mono or stereo support
            int channels = min(2, _buffer?.numberOfChannels ?? 2);
            bool stereo = channels == 2;

            Int16List left = new Int16List(_buffer!.length!);
            Int16List right = stereo ? new Int16List(_buffer!.length!) : left;

            for (int c=0; c < channels; c++) {
            Float32List src = _buffer!.getChannelData(c);
            Int16List dest = (c == 0) ? left : right;
            for (int i=0; i<src.length; i++) {
                num s = max(-1, min(1, src[i]));
                dest[i] = (s * (1 << 15)).round();
            }
            }

            if (stereo) {
            return js.context.callMethod('encodeMP3Stereo', [ left, right, sampleRate ]);
            } else {
            return js.context.callMethod('encodeMP3Mono', [ left, sampleRate ]);
            }
        }
    */
        /// encodes the audio buffer as a WAV byte array
        toWAV() {
            // only mono or stereo support
            const channels = Math.min(2, this.numberOfChannels);
            const rate = this.sampleRate;
            const stereo = (channels == 2);
            const len = this.samples;
            const wav = new Int16Array(len * channels + 23);
            wav[0] = 0x4952; // "RI"
            wav[1] = 0x4646; // "FF"
            wav[2] = (2 * len * channels + 15) & 0x0000ffff; // RIFF size
            wav[3] = ((2 * len * channels + 15) & 0xffff0000) >> 16; // RIFF size
            wav[4] = 0x4157; // "WA"
            wav[5] = 0x4556; // "VE"
            wav[6] = 0x6d66; // "fm"
            wav[7] = 0x2074; // "t "
            wav[8] = 0x0012; // fmt chunksize: 18
            wav[9] = 0x0000;
            wav[10] = 0x0001; // format tag : 1
            wav[11] = channels; // channels: 2 or 1
            wav[12] = rate & 0x0000ffff; // sample per sec
            wav[13] = (rate & 0xffff0000) >> 16; // sample per sec
            wav[14] = (2 * channels * rate) & 0x0000ffff; // byte per sec
            wav[15] = ((2 * channels * rate) & 0xffff0000) >> 16; // byte per sec
            wav[16] = channels * 2; // block align
            wav[17] = 16; // bits per sample
            wav[18] = 0x0000; // cb size
            wav[19] = 0x6164; // "da"
            wav[20] = 0x6174; // "ta"
            wav[21] = (2 * len * channels) & 0x0000ffff; // data size[byte]
            wav[22] = ((2 * len * channels) & 0xffff0000) >> 16; // data size[byte]
            const leftSource = this.channels[0];
            const rightSource = stereo ? this.channels[1] : leftSource;
            for (let i = 0; i < len; i++) {
                for (let c = 0; c < channels; c++) {
                    let sample = (c === 0) ? leftSource[i] : rightSource[i];
                    sample = Math.max(-1.0, Math.min(1.0, sample));
                    sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    wav[i * channels + c + 23] = Math.round(sample);
                }
            }
            return new Uint8Array(wav.buffer);
        }
        /**
         * downloads a WAV file as a blob
         */
        downloadWAV(filename) {
            //TESTME!
            const wav = this.toWAV();
            const blob = new Blob([wav], { type: "audio/wav" });
            const objectUrl = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = objectUrl;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(objectUrl);
        }
        /// downloads an MP3 file as a blob
        /*
        Future? downloadMP3(String filename) {
          Uint8List? mp3 = toMP3();
          Blob? blob = new Blob([ mp3 ], "audio/mp3");
          if (blob != null) {
            String objectUrl = Url.createObjectUrlFromBlob(blob);
            AnchorElement link = new AnchorElement();
            link.href = objectUrl;
            link.download = filename;
            link.click();
            Url.revokeObjectUrl(objectUrl);
          }
        }
        */
        /// encode audio buffer as a base64 encoded MP3 file
        /*
        String? toMP3Base64() {
          Uint8List? mp3 = toMP3();
          return (mp3 != null) ? "data:audio/mp3;base64,${base64.encode(mp3)}" : null;
        }
        */
        /**
         * encode audio buffer as a base64 encoded WAV file
         */
        toWAVBase64() {
            const wav = this.toWAV();
            //TESTME
            return `data:audio/wav;base64,${btoa(wav.toString())}`;
        }
    }

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    /// frequency (Hz) of note A in octave 0
    /// frequency (Hz) of note C in octave 0
    const C0Hz = 16.3516;
    /// musical notes (in half steps) in the 12-note chromatic scale
    ///              0    1     2    3     4    5    6     7    8     9    10    11
    const NOTES = ["C", "C♯", "D", "D♯", "E", "F", "F♯", "G", "G♯", "A", "A♯", "B"];
    /// pitch to color mappings
    const NOTE_COLORS = [
        "rgb(229, 76, 78)",
        "rgb(223, 132, 74)",
        "rgb(228, 171, 81)",
        "rgb(227, 199, 73)",
        "rgb(223, 228, 78)",
        "rgb(174, 215, 71)",
        "rgb(63, 188, 70)",
        "rgb(63, 169, 180)",
        "rgb(64, 124, 180)",
        "rgb(78, 69, 179)",
        "rgb(141, 69, 183)",
        "rgb(202, 69, 147)"
    ];
    class Note {
        get note() { return this._note; }
        set note(n) { this._note = n; }
        /// when this note will finish playing
        get end() { return this.start + this.duration; }
        /// note octave (0 - 8) maintains current note letter
        get octave() { return Math.floor(this.note / 12); }
        set octave(o) { this.note = o * 12 + this.step; }
        /// note half-step (0 - 11) maintains current octave
        // synthPatch-es rely on this to get their pitch. Must be floating point to allow microtones.
        get step() { return this.note % 12; }
        set step(s) { this.note = this.octave * 12 + s; }
        /// how many cents off from perfect pitch for this half-step
        get cents() { return Math.round((this.note - Math.floor(this.note)) * 100); }
        get velocity() { return this._velocity; }
        set velocity(v) { this._velocity = clamp(v, 0, 127); }
        /// velocity to gain conversion
        get gain() { return (this.velocity * this.velocity) / (127 * 127); }
        set gain(g) { this.velocity = Math.sqrt(g * 127 * 127); }
        /// note name (e.g. "C", "D♯")
        get name() { return `${NOTES[Math.floor(this.step)]}`; }
        /// accidental (either ♯ or empty string)
        get accidental() { return this.name.substring(1); }
        /// 0 == C-1; 12 == C0; 24 == C1
        get nameWithOctave() { return `${NOTES[Math.round(this.step)]}${this.octave - 1}`; }
        /// step value color match
        get stepColor() { return NOTE_COLORS[Math.round(this.step) % NOTE_COLORS.length]; }
        /// note "playback rate"
        get rate() { return Math.pow(2, this.note / 12); }
        /// note frequency (Hz)
        get frequency() { return C0Hz * this.rate; }
        set frequency(f) { if (f > 0)
            this.note = 12 * Math.log(f / C0Hz) / Math.LN2; }
        /// create a note from a midi code (0-127)
        constructor(n) {
            /// midi note number
            this._note = 60; // middle C
            /// when in the future this note will be played (time in beats)
            this.start = 0.0;
            /// duration of the note in beats (quarter notes)
            this.duration = 1.0;
            /// midi velocity (0 - 127)
            this._velocity = 90;
            this.note = n;
        }
        isEqual(other) {
            return (this.note === other.note &&
                this.start === other.start &&
                this.duration === other.duration &&
                this.velocity === other.velocity);
        }
        clone() {
            let n = new Note(this.note);
            n.start = this.start;
            n.duration = this.duration;
            n.velocity = this.velocity;
            return n;
        }
        /// create a note by name (e.g. D#4, C2)
        static fromName(name) {
            const note = new Note(60);
            note.octave = Note.nameToOctave(name);
            note.step = Note.nameToStep(name);
            return note;
        }
        static fromFrequency(freq) {
            const note = new Note(60);
            note.frequency = freq;
            return note;
        }
        static nameToOctave(n) {
            if (n.length == 2) {
                let c = n.codePointAt(1);
                if (c)
                    return clamp(c - 48, 0, 8);
            }
            else if (n.length > 2) {
                let c = n.codePointAt(2);
                if (c)
                    return clamp(c - 48, 0, 8);
            }
            return 0;
        }
        static nameToStep(n) {
            if (n == null || n == "") {
                return 0;
            }
            else if (n.length <= 2) {
                n = n[0].toUpperCase();
            }
            else {
                n = n.substring(0, 2).toUpperCase();
            }
            return Math.max(0, NOTES.indexOf(n));
        }
        /// if the given note name with octave is valid, return note number
        /// else return -1;
        static nameToNote(s) {
            if (s.length < 2 || s.length > 3)
                return -1;
            s = s.replaceAll('#', '♯');
            for (let step = 0; step < 12; step++) {
                if (s.startsWith(NOTES[step])) {
                    const t = s.substring(NOTES[step].length);
                    if (['0', '1', '2', '3', '4', '5', '6', '7', '8'].includes(t)) {
                        let c = t.codePointAt(0);
                        const octave = (c ? c : 48) - 48;
                        return octave * 12 + step;
                    }
                }
            }
            return -1;
        }
    }
    function clamp(value, minimum, maximum) {
        return Math.max(minimum, Math.min(maximum, value));
    }

    /*
     * TunePad
     * Northwestern University
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    /**
     * A Trace object is generated by the python compiler and represents a list of
     * audio events that generate music.
     */
    class MusicTrace {
        /// number of events in the trace
        get length() { return this.trace.length; }
        /// is this trace empty
        get isEmpty() { return this.length === 0; }
        get beats() { return this._beats; }
        get minNote() { return this._minNote; }
        get minOctave() { return Math.max(0, Math.floor(this._minNote / 12)); }
        get maxNote() { return this._maxNote; }
        get maxOctave() { return Math.max(0, Math.floor(this._minNote / 12)); }
        /// what's the range between the highest and lowest note values
        get noteRange() { return (this.maxNote - this.minNote); }
        get octaveRange() { return (this.maxOctave - this.minOctave); }
        get noteCount() { return this._noteCount; }
        constructor() {
            /// a trace is just a list of events
            this.trace = new Array();
            /// number of beats in the trace (to the end of the last note)
            this._beats = 0;
            /// current position of the playhead as the trace is being constructed
            this._playhead = 0;
            /// what's the minimum note value in this trace (or -1 if there are no notes)
            this._minNote = -1;
            /// what's the maximum note value in this trace (or -1 if there are no notes)
            this._maxNote = -1;
            /// how many notes in this trace?
            this._noteCount = 0;
        }
        clear() {
            this.trace = [];
            this._beats = 0;
            this._minNote = -1;
            this._maxNote = -1;
            this._noteCount = 0;
            this._playhead = 0;
        }
        fromPython(list) {
            for (let t of list)
                this.addTraceEvent(t);
        }
        get messages() {
            return this.trace.filter(t => t.params.get('type') === 'message');
        }
        get unitTests() {
            return this.trace.filter(t => ['pass', 'fail'].includes(t.params.get('type')));
        }
        get passes() {
            return this.trace.filter(t => t.params.get('type') === 'pass');
        }
        get fails() {
            return this.trace.filter(t => t.params.get('type') === 'fail');
        }
        /**
         * Compare two trace objects to see if they are equivalent except for line numbers
         */
        isEquivalent(other) {
            if (this.length !== other.length)
                return false;
            for (let i = 0; i < this.length; i++) {
                if (!this.trace[i].isEquivalent(other.trace[i]))
                    return false;
            }
            return true;
        }
        /**
         * Add an event to the trace
         */
        addTraceEvent(e) {
            this._addTraceEvent(TraceEvent.fromMap(e));
        }
        _addTraceEvent(event) {
            this.trace.push(event);
            switch (event.command) {
                case TraceEvent.PLAY:
                    this._beats = Math.max(event.end, this._beats);
                    this._playhead = event.end;
                    if (this._minNote < 0 || event.note.note < this._minNote) {
                        this._minNote = event.note.note;
                    }
                    this._maxNote = Math.max(this._maxNote, event.note.note);
                    this._noteCount++;
                    break;
                case TraceEvent.SOUND:
                    this._beats = Math.max(event.end, this._beats);
                    this._playhead = event.end;
                    this._noteCount++;
                    break;
                case TraceEvent.REST:
                    this._beats = Math.max(event.end, this._beats);
                    this._playhead = event.end;
                    break;
            }
        }
        /**
         * Return a list of events for the given trace group number
         */
        getTraceGroup(bug) {
            return this.trace.filter((e) => e.trace_group === bug);
        }
    }
    /**
     * Audio trace of a program's execution. Trace events are generated by
     * python and then replayed to generate sounds and animation.
     */
    class TraceEvent {
        /// end time of the event in beats
        get end() { return this.time + this.duration; }
        constructor(command, time) {
            /// start time of the event in beats
            this.time = 0;
            /// duration of the event in beats
            this.duration = 1;
            /// python source line number of this command
            this.line = -1;
            /// note to play (for playNote and playSound)
            this.note = new Note(60);
            /// trace "group" that this event belongs to. all events 
            /// generated by the same python function call will have 
            /// matching trace ids.
            this.trace_group = -1;
            /// any additional parameters
            this.params = new Map();
            this.id = TraceEvent._TRACE_ID++;
            this.command = command;
            this.time = time;
        }
        clone() {
            let e = new TraceEvent(this.command, this.time);
            e.line = this.line;
            e.duration = this.duration;
            e.note = this.note.clone();
            for (let [key, value] of this.params) {
                e.params.set(key, value);
            }
            return e;
        }
        static fromMap(m) {
            let e = new TraceEvent(String(m.get('command')), Math.max(0, Number(m.get('time'))));
            e.duration = Number(m.get('duration'));
            e.note.duration = e.duration;
            for (let [key, val] of m) {
                if (key === "note" && typeof val === 'number') {
                    e.note.note = val;
                }
                else if (key === "pitch" && typeof val === 'number') {
                    e.note.note = val + 60;
                }
                else if (key === "velocity" && typeof val === 'number') {
                    e.note.velocity = val;
                }
                else if (key === "sustain" && typeof val === 'number') {
                    e.note.duration = Math.max(e.note.duration, val);
                    e.duration = e.note.duration;
                }
                else if (key === "line" && typeof val === 'number') {
                    e.line = val;
                }
                else if (key === "trace") {
                    e.trace_group = val;
                }
                else if (["command", "time", "duration"].includes(key)) {
                    continue;
                }
                else {
                    e.params.set(key, val);
                }
            }
            return e;
        }
        /**
         * Are two trace events the same except for their line numbers
         */
        isEquivalent(other) {
            if (this.command === other.command &&
                this.time === other.time &&
                this.duration === other.duration &&
                this.note.isEqual(other.note)) {
                for (let [key, val] of this.params) {
                    if (key !== 'line' && other.params.get(key) !== val) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }
    }
    TraceEvent.PLAY = "play"; /// command code to play a note
    TraceEvent.SOUND = "sound"; /// command to play a custom sound recording
    TraceEvent.REST = "rest"; /// rest for an interval
    TraceEvent.PUSH_FX = "push_fx"; /// push an audio effect
    TraceEvent.POP_FX = "pop_fx"; /// pop the audio effect stack
    TraceEvent.MESSAGE = "message";
    /// used to generate unique trace event IDs
    TraceEvent._TRACE_ID = 0;

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    /**
     * Stores a compressed/reduced version of an audio buffer with just enough information to
     * render a waveform visualization.
     */
    class WaveformData {
        // waveform visualization sample rate (e.g. draw one bar for every N seconds of audio)
        get waveRate() { return this.sampleRate / this.waveQuantum; }
        get isEmpty() { return this.waveform.length == 0; }
        // length of the waveform in seconds
        get duration() { return this.waveform.length / this.waveRate; }
        /**
         * Create a new empty waveform
         */
        constructor() {
            this.waveform = new Array();
            // source audio sample rate (hardcoded for now)
            this.sampleRate = 44100;
            // each datapoint of the visualization represents 256 audio samples;
            this.waveQuantum = 128;
            this._top_path = new Array();
            this._bottom_path = new Array();
            this._wavelines = document.createElementNS("http://www.w3.org/2000/svg", 'g');
            this._wavepath = document.createElementNS("http://www.w3.org/2000/svg", 'path');
        }
        /**
         * Appends one waveform sample representing 256 underlying audio samples (waveQuantum)
         */
        appendSample(sample) {
            if (sample.length >= 2) {
                this.waveform.push(sample);
                const time = this.duration;
                const y1 = Math.sign(sample[1]) * clamp$1(Math.sqrt(Math.abs(sample[1])), 0, 1);
                const y2 = Math.sign(sample[0]) * clamp$1(Math.sqrt(Math.abs(sample[0])), 0, 1);
                const line = document.createElementNS("http://www.w3.org/2000/svg", 'line');
                line.setAttribute('x1', `${time}`);
                line.setAttribute('x2', `${time}`);
                line.setAttribute('y1', `${y1}`);
                line.setAttribute('y2', `${y2}`);
                line.classList.add('waveline');
                this._wavelines.append(line);
                this._top_path.push("L", time, y1);
                this._bottom_path.unshift("L", time, y2);
            }
        }
        /**
         * Append the given audio data to this waveform.
         */
        appendBuffer(buffer) {
            const left = buffer.getChannelData(0);
            const right = (buffer.numberOfChannels > 1) ? buffer.getChannelData(1) : left;
            const stride = this.waveQuantum;
            let amin = 0, amax = 0;
            for (let i = 0; i < buffer.length; i++) {
                amin = Math.min(amin, Math.min(left[i], right[i]));
                amax = Math.max(amax, Math.max(left[i], right[i]));
                if (((i + 1) % stride) === 0) {
                    this.appendSample([amin, amax]);
                    amax = 0.0;
                    amin = 0.0;
                }
            }
        }
        /**
         * Create a new buffer from the given AudioBuffer object
         */
        static fromBuffer(buffer) {
            const wave = new WaveformData();
            wave.appendBuffer(buffer);
            return wave;
        }
        get wavepath() {
            const d = ["M", 0, 0, ...this._top_path, ...this._bottom_path, "Z"].join(' ');
            this._wavepath.setAttribute("d", d);
            return this._wavepath;
        }
        get wavelines() {
            return this._wavelines;
        }
    }

    class SynthEvent {
        constructor(note, chain) {
            this.released = false;
            this.canceled = false;
            this.note = note;
            this.chain = chain;
        }
    }

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    class SynthModulator {
        constructor(context, name, value) {
            this.value = 1.0;
            this.gain = new GainNode(context);
            this.name = name;
            this.value = value;
            this.gain.gain.value = value;
        }
        connect(connector, dest) {
            if (dest == this.name) {
                connector.level.connect(this.gain);
                return true;
            }
            else {
                return false;
            }
        }
        destroy() {
            this.gain.disconnect();
        }
        updateParameter(pname, newValue) {
            if (pname == `${this.name}-mod}`) {
                this.value = toNum(newValue, this.value);
                this.gain.gain.value = this.value;
                return true;
            }
            return false;
        }
    }

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    class SynthNode {
        constructor(context, config) {
            /// unique id number for this node in this patch
            this.id = 0;
            /// param modulator attachment points
            this.modulators = new Array();
            /// list of outgoing connectors
            this.connectors = new Array();
            this.context = context;
            this.id = parseInt(config.id);
            this.level = context.createGain();
            const db = toNum(config.level, 0.0);
            this.level.gain?.setValueAtTime(dBToGain(db), 0);
            this.level.gain.value = dBToGain(db);
            this.addModulator('gain', toNum(config['gain-mod'], 1.0), this.level.gain);
        }
        /// connect to this node from a source node. the dest string specifies
        /// which parameter or input to connect to
        connect(connector, dest) {
            for (let mod of this.modulators) {
                if (mod.connect(connector, dest)) {
                    return;
                }
            }
            if (dest == 'level') {
                connector.level.connect(this.level.gain);
            }
            else {
                connector.level.connect(this.level);
            }
        }
        addConnector(connector) {
            this.connectors.push(connector);
            this.level?.connect(connector.level);
        }
        addModulator(name, value, param) {
            const mod = new SynthModulator(this.context, name, value);
            mod.gain.connect(param);
            this.modulators.push(mod);
        }
        /// start the note immediately (key down / note on)
        playNote(note) { }
        /// release the note (key up / note off)
        releaseNote() { }
        /// schedule a note to be played in the future
        /// when: when to play the note (seconds from current time)
        /// if when is 0, start now
        /// if when is positive, delay that many seconds before starting
        /// if when is negative, possibly play a partial note
        /// if (when + duration) is less than or equal to zero do nothing
        /// release: how much extra time to let the note ring out (seconds)
        scheduleNote(note, when, duration, release) { }
        /// immediately stop playback and cancel all future scheduled notes
        cancelNotes() { }
        /// disconnect audio chain to ensure garbage collection
        destroy() {
            this.level.disconnect();
            this.modulators.forEach(mod => mod.destroy());
            this.connectors.forEach(conn => conn.destroy());
        }
        pitchBend(cents) { }
        schedulePitchBend(start, cents) { }
        /// update a node parameter by name
        updateParameter(pname, newValue) {
            for (let mod of this.modulators) {
                if (mod.updateParameter(pname, newValue))
                    return;
            }
            if (pname == 'level') {
                const db = toNum(newValue, 0.0);
                this.level.gain?.setValueAtTime(dBToGain(db), 0);
                this.level.gain.value = dBToGain(db);
            }
        }
        updateConnectorLevel(connectorId, dB) {
            this.connectors.forEach((c) => {
                if (c.id == connectorId) {
                    c.updateLevel(dB);
                }
            });
        }
        /// returns data for visualizing node state (e.g. oscillator curve or ADSR envelope shape)
        /*
        getVisualizationData() : Future<Float32List> {
            return Future.sync(() => Float32List(0));
        }
        */
        attachAnalyzer(connectorId, fftSize, channels) {
            for (let c of this.connectors) {
                if (c.id == connectorId) {
                    c.attachAnalyzer(fftSize, channels);
                }
            }
        }
        detachAnalyzer(connectorId) {
            this.connectors.forEach((c) => {
                if (c.id == connectorId) {
                    c.detachAnalyzer();
                }
            });
        }
        getFloatTimeDomainData(connectorId, channel, buff) {
            this.connectors.forEach((c) => {
                if (c.id == connectorId) {
                    c.getFloatTimeDomainData(channel, buff);
                }
            });
        }
    }

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
      *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    //-----------------------------------------------------------------------
    // Simplified ADSR Envelope Node
    //-----------------------------------------------------------------------
    class ADSRNode extends SynthNode {
        constructor(context, config) {
            super(context, config);
            /// 'attack' value of the ADSR envelope for this note (seconds)
            this.A = 0.1;
            /// 'decay' value of the ADSR envelope for this note (seconds)
            this.D = 0.1;
            /// 'sustain' value of the ADSR envelope for this note (0.0 - 1.0)
            this.S = 1.0;
            /// 'release' value of the ADSR envelope for this note (seconds)
            this.R = 0.2;
            // curve shapes: 1 -> line, >1 -> exp, <1 -> log.
            this.aShape = 5.0;
            this.dShape = 2.0;
            this.rShape = 2.0;
            this.attackCurve = [];
            this.decayCurve = [];
            this.releaseCurve = [];
            this.A = toNum(config['A'], this.A);
            this.D = toNum(config['D'], this.D);
            this.S = toNum(config['S'], this.S);
            this.R = toNum(config['R'], this.R);
            this.R = Math.max(this.R, 0.01);
            this.aShape = toNum(config['a shape'], this.aShape);
            this.dShape = toNum(config['d shape'], this.dShape);
            this.rShape = toNum(config['r shape'], this.rShape);
            this._attack = context.createGain();
            this._decay = context.createGain();
            this._release = context.createGain();
            this._attack.gain.value = 0.0;
            this._decay.gain.value = 1.0;
            this._release.gain.value = 1.0;
            this._attack.connect(this._decay);
            this._decay.connect(this._release);
            this._release.connect(this.level);
            this._buildCurves();
        }
        connect(source, dest) {
            source.level.connect(this._attack);
        }
        playNote(note) {
            let when = this.context.currentTime;
            try {
                this._attack.gain?.cancelScheduledValues(0);
                this._decay.gain?.cancelScheduledValues(0);
                this._release.gain?.cancelScheduledValues(0);
                // this logic is necessary for drum samples to have the right punch level
                if (this.A > 0) {
                    this._attack.gain?.setValueAtTime(0.0, when);
                }
                else {
                    this._attack.gain?.setValueAtTime(1.0, when);
                }
                this._decay.gain?.setValueAtTime(1.0, when);
                this._release.gain?.setValueAtTime(1.0, when);
                when = this.context.currentTime + 0.01;
                if (this.A > 0) {
                    this._attack.gain?.setValueCurveAtTime(this.attackCurve, when, this.A);
                }
                else {
                    this._attack.gain?.setValueAtTime(1.0, when);
                }
                if (this.D > 0) {
                    this._decay.gain?.setValueCurveAtTime(this.decayCurve, when + this.A, this.D);
                }
                else {
                    this._decay.gain?.setValueAtTime(this.S, when + this.A);
                }
            }
            catch (x) {
                console.log('Exception in ADSR playNote $x.');
            }
        }
        releaseNote() {
            const when = this.context.currentTime;
            if (this.R > 0) {
                this._attack.gain?.cancelScheduledValues(when);
                this._decay.gain?.cancelScheduledValues(when);
                this._release.gain?.setValueCurveAtTime(this.releaseCurve, when, this.R);
            }
            else {
                this._release.gain?.setValueAtTime(0.0, when);
            }
        }
        scheduleNote(note, when, duration, release) {
            const offset = (when < 0) ? -when : 0;
            when = (when < 0) ? 0 : when;
            let start = when + this.context.currentTime;
            // this logic is necessary for drum samples to have the right punch level
            if (this.A > 0) {
                this._attack.gain?.setValueAtTime(0.0, start);
            }
            else {
                this._attack.gain?.setValueAtTime(1.0, start);
            }
            this._decay.gain?.setValueAtTime(1.0, start);
            this._release.gain?.setValueAtTime(1.0, start); // exception here
            start += 0.01;
            if (this.A > 0 && this.A > offset) {
                const a = this.A - offset;
                this._attack.gain?.setValueCurveAtTime(this.attackCurve, start, a);
            }
            else {
                this._attack.gain?.setValueAtTime(1.0, start);
            }
            if (this.D > 0 && this.A + this.D > offset && duration > this.A) {
                const d = (offset >= this.A) ? this.D - (offset - this.A) : this.D;
                const s = (offset >= this.A) ? start : start + this.A - offset;
                this._decay.gain?.setValueCurveAtTime(this.decayCurve, s, d);
                if (this.A + this.D > duration) {
                    this._decay.gain?.cancelScheduledValues(start + duration - offset);
                }
            }
            else {
                this._decay.gain?.setValueAtTime(this.S, Math.max(0, start + this.A + this.D - offset));
            }
            if (duration + this.R > offset) {
                const r = (offset >= duration) ? this.R - (offset - duration) : this.R;
                this._release.gain?.setValueCurveAtTime(this.releaseCurve, start + duration - offset, r);
            }
            else {
                this._release.gain?.setValueAtTime(0.0, start);
            }
        }
        cancelNotes() {
            super.cancelNotes();
            const when = this.context.currentTime;
            this._release.gain?.cancelScheduledValues(when);
            this._release.gain.value = 0.0;
            this._attack.gain?.cancelScheduledValues(when);
            this._attack.gain.value = 0.0;
            this._decay.gain?.cancelScheduledValues(when);
            this._decay.gain.value = 0.0;
        }
        destroy() {
            super.destroy();
            this._attack.disconnect();
            this._decay.disconnect();
            this._release.disconnect();
        }
        updateParameter(pname, newValue) {
            super.updateParameter(pname, newValue);
            switch (pname) {
                case 'A':
                    this.A = toNum(newValue, this.A);
                    break;
                case 'D':
                    this.D = toNum(newValue, this.D);
                    break;
                case 'S':
                    this.S = toNum(newValue, this.S);
                    break;
                case 'R':
                    this.R = toNum(newValue, this.R);
                    break;
                case 'a shape':
                    this.aShape = toNum(newValue, this.aShape);
                    break;
                case 'd shape':
                    this.dShape = toNum(newValue, this.dShape);
                    break;
                case 'r shape':
                    this.rShape = toNum(newValue, this.rShape);
                    break;
            }
            this.R = Math.max(this.R, 0.01);
            this._buildCurves();
        }
        /// build Attack, Decay, and Release curves
        _buildCurves() {
            this._buildAttackCurve(this.aShape);
            this._buildDecayCurve(this.dShape);
            this._buildReleaseCurve(this.rShape);
        }
        _buildAttackCurve(shape) {
            shape = clamp$1(shape, 0.001, 8.0);
            this.attackCurve = [];
            const samples = Math.ceil(ADSRNode.samplesPerSecond * this.A);
            if (samples > 0) {
                for (let i = 0; i <= samples; i++) {
                    let p = i / samples;
                    p = Math.pow(p, shape);
                    this.attackCurve.push(p);
                    //num db = 50 * (i / samples - 1);
                    //_Acurve.add(dBToGain(db).toDouble());
                }
            }
        }
        _buildDecayCurve(shape) {
            shape = clamp$1(shape, 0.001, 4.0);
            this.decayCurve = [];
            const samples = Math.ceil(ADSRNode.samplesPerSecond * this.D);
            if (samples > 0) {
                for (let i = 0; i <= samples; i++) {
                    let p = i / samples;
                    p = 1 - Math.pow(p, shape);
                    this.decayCurve.push((1.0 - this.S) * p + this.S);
                }
            }
        }
        _buildReleaseCurve(shape) {
            shape = clamp$1(shape, 0.001, 4.0);
            this.releaseCurve = [];
            const samples = Math.ceil(ADSRNode.samplesPerSecond * this.R);
            if (samples > 0) {
                for (let i = 0; i <= samples; i++) {
                    let p = i / samples;
                    p = 1 - Math.pow(p, shape);
                    this.releaseCurve.push(p);
                }
            }
        }
    }
    /// sample rate for envelope curves
    ADSRNode.samplesPerSecond = 300;

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    //-----------------------------------------------------------------------
    // connectors are wired between connected nodes in the synth chain.
    // connectors have output gain levels and can be used connnect analyzer
    // nodes to inspect different links in the chain.
    //-----------------------------------------------------------------------
    class SynthConnector {
        get context() { return this.source.context; }
        constructor(source, config) {
            /// unique id number for this connector in this patch
            this.id = 0;
            /// level value in decibels
            this.dB = 0.0;
            /// used to splice in a multi-channel analyzer node
            this._pre = null;
            this._analyzers = new Array();
            this._splitter = null;
            this._merger = null;
            this._buffer = null;
            this.type = '';
            this.source = source;
            this.id = toInt(config['id'], -1);
            this.level = new GainNode(this.context);
            this.dB = toNum(config['level'], 0.0);
            this.level.gain?.setValueAtTime(dBToGain(this.dB), 0);
            this.type = toStr(config['type'], '');
        }
        updateLevel(dB) {
            this.dB = dB;
            (this._pre ?? this.level).gain?.setValueAtTime(dBToGain(dB), 0);
        }
        destroy() {
            this.level.disconnect();
        }
        attachAnalyzer(fftSize, channels, minDB = -60, maxDB = 5) {
            // maximum of 6 channels
            channels = clamp$1(channels, 1, 6);
            // splice the analyzers into the chain
            this._pre = new GainNode(this.context);
            this._splitter = this.context.createChannelSplitter(channels);
            this._merger = this.context.createChannelMerger(channels);
            this._pre.gain?.setValueAtTime(dBToGain(this.dB), 0);
            this.level.gain?.setValueAtTime(1.0, 0);
            this.source.level.disconnect(this.level);
            this.source.level.connect(this._pre);
            this._pre?.connect(this._splitter);
            this._merger?.connect(this.level);
            // create the analyzers
            for (let c = 0; c < channels; c++) {
                let analyzer = new AnalyserNode(this.level.context);
                this._analyzers.push(analyzer);
                analyzer.fftSize = fftSize;
                analyzer.minDecibels = minDB;
                analyzer.maxDecibels = maxDB;
                this._splitter?.connect(analyzer, c, 0);
                analyzer.connect(this._merger, 0, c);
                if (c == 0) {
                    this._buffer = new Float32Array(analyzer.frequencyBinCount);
                }
            }
        }
        detachAnalyzer() {
            if (this._pre != null) {
                this.level.gain?.setValueAtTime(dBToGain(this.dB), 0);
                this.source.level.disconnect(this._pre);
                this._pre?.disconnect();
                this._splitter?.disconnect();
                this._merger?.disconnect();
                for (let analyzer of this._analyzers) {
                    analyzer.disconnect();
                }
                this.source.level.connect(this.level);
                this._pre = null;
                this._buffer = null;
                this._splitter = null;
                this._merger = null;
                this._analyzers = [];
            }
        }
        getFloatTimeDomainData(channel, buff) {
            if (channel < this._analyzers.length) {
                const analyzer = this._analyzers[channel];
                if (this._buffer != null && buff.length == this._buffer.length) {
                    analyzer.getFloatTimeDomainData(this._buffer);
                    for (let i = 0; i < buff.length; i++) {
                        buff[i] += this._buffer[i];
                    }
                }
            }
        }
    }

    class SynthFilterNode extends SynthNode {
        constructor(context, config) {
            super(context, config);
            /// keyboard tracking enabled (adjust frequency based on source note pitch)
            this.tracking = true;
            this.ratio = 1.0;
            /// configurable parameters
            this.frequency = 350.0; // hz default value of 350.0;
            this.Q = 1.0; // range: 0.0001 to 1000 (default 1.0)
            this.gain = 0.0; // decibels range: -40 to 40 (default 0.0)
            this.detune = 0; // cents with default of 0
            this.type = "lowpass";
            // set up audio node chain
            this.filter = context.createBiquadFilter();
            this.filter.connect(this.level);
            // set up parameters
            this.Q = clamp$1(toNum(config['Q'], 1.0), 0.0001, 1000);
            this.gain = clamp$1(toNum(config['gain'], 0.0), -40, 40);
            this.type = toStr(config['filter type'], 'lowpass');
            this.detune = toNum(config['detune'], 0);
            this.frequency = clamp$1(toNum(config['frequency'], 350.0), 0, 16700);
            this.tracking = toBool(config['tracking'], true);
            this.ratio = toNum(config['tracking ratio'], 1.0);
            this.addModulator('Q', toNum(config['Q-mod'], 1.0), this.filter.Q);
            this.addModulator('gain', toNum(config['gain-mod'], 5), this.filter.gain);
            this.addModulator('frequency', toNum(config['frequency-mod'], 1000), this.filter.frequency);
            // set up filter node parameters
            this.filter.Q.value = this.Q;
            this.filter.gain.value = this.gain;
            this.filter.type = this.type;
            this.filter.detune.value = this.detune;
            this.filter.frequency.value = this.frequency;
        }
        playNote(note) {
            // keyboard tracking: set the frequency to be relative to the pitch
            const f = this.tracking ? (note.frequency * this.ratio) + this.frequency : this.frequency;
            const now = this.context.currentTime;
            this.filter.Q?.setValueAtTime(this.Q, now);
            this.filter.gain?.setValueAtTime(this.gain, now);
            this.filter.detune?.setValueAtTime(this.detune, now);
            this.filter.frequency?.setValueAtTime(f, now);
        }
        scheduleNote(note, when, duration, release) {
            when = (when < 0) ? 0 : when;
            const now = this.context.currentTime;
            const f = this.tracking ? (note.frequency * this.ratio) + this.frequency : this.frequency;
            this.filter.Q?.setValueAtTime(this.Q, when + now);
            this.filter.gain?.setValueAtTime(this.gain, when + now);
            this.filter.detune?.setValueAtTime(this.detune, when + now);
            this.filter.frequency?.setValueAtTime(f, when + now);
        }
        cancelNotes() {
            super.cancelNotes();
            this.filter.Q?.cancelScheduledValues(0);
            this.filter.gain?.cancelScheduledValues(0);
            this.filter.detune?.cancelScheduledValues(0);
            this.filter.frequency?.cancelScheduledValues(0);
        }
        destroy() {
            super.destroy();
            this.filter.disconnect();
        }
        connect(source, dest) {
            if (dest === 'audio') {
                source.level.connect(this.filter);
            }
            else {
                super.connect(source, dest);
            }
        }
        /// update a node parameter by name
        updateParameter(pname, newValue) {
            const now = this.context.currentTime;
            if (pname === 'filter type' && SynthFilterNode.FILTERS.includes(newValue)) {
                this.type = toStr(newValue, 'lowpass');
                this.filter.type = this.type;
            }
            else if (pname === 'Q') {
                this.Q = clamp$1(toNum(newValue, this.Q), 0.0001, 1000);
                this.filter.Q.cancelScheduledValues(0);
                this.filter.Q.setValueAtTime(this.Q, now);
                this.filter.Q.value = this.Q;
            }
            else if (pname === 'gain') {
                this.gain = clamp$1(toNum(newValue, this.gain), -40, 40);
                this.filter.gain.cancelScheduledValues(0);
                this.filter.gain.setValueAtTime(this.gain, now);
                this.filter.gain.value = this.gain;
            }
            else if (pname === 'detune') {
                this.detune = toNum(newValue, this.detune);
                this.filter.detune?.cancelScheduledValues(0);
                this.filter.detune?.setValueAtTime(this.detune, now);
            }
            else if (pname === 'frequency') {
                this.frequency = clamp$1(toNum(newValue, this.frequency), 0, 16700);
                this.filter.frequency?.cancelScheduledValues(0);
                this.filter.frequency?.setValueAtTime(this.frequency, now);
                this.filter.frequency.value = this.frequency;
            }
            else if (pname === 'tracking') {
                this.tracking = toBool(newValue, this.tracking);
            }
            else if (pname === 'ratio') {
                this.ratio = toNum(newValue, this.ratio);
            }
            else {
                super.updateParameter(pname, newValue);
            }
        }
    }
    /// list of all valid filter types
    SynthFilterNode.FILTERS = [
        "lowpass", "highpass", "bandpass",
        "allpass", "lowshelf", "highshelf",
        "peaking", "notch", 'allpass'
    ];

    //-----------------------------------------------------------------------
    // Oscillator Node: simple built-in waveforms
    //-----------------------------------------------------------------------
    class SynthOscNode extends SynthNode {
        constructor(context, config) {
            super(context, config);
            /// frequency of the oscillator (for fixed frequency)
            this.frequency = 440.0; // Hz
            /// frequency multiplier for relative frequency mode
            this.multiplier = 1.0;
            /// the detune setting of the osc from the designer ui
            this.detune = 0.0;
            /// if true, the frequency is relative to the note being played
            this.relative = true;
            /// name of waveform from ui selector
            this.waveform = 'sine';
            this.waveform = toStr(config['waveform'], 'sine');
            this.frequency = toNum(config['frequency'], this.frequency);
            this.detune = toNum(config['detune'], 0.0);
            this.relative = toBool(config['relative'], true);
            this.multiplier = toNum(config['multiplier'], this.multiplier);
            this.osc = context.createOscillator();
            this.gain = new GainNode(context);
            this.shaper = context.createWaveShaper();
            this.addModulator('detune', toNum(config['detune-mod'], 500), this.osc.detune);
            this.addModulator('frequency', toNum(config['frequency-mod'], 1000), this.osc.frequency);
            this.addModulator('amplitude', toNum(config['amplitude-mod'], 1.0), this.level.gain);
            this.gain.gain.value = 0.3;
            if (!SynthOscNode.Waveforms.includes(this.waveform))
                this.waveform = 'sine';
            this.osc.frequency.setValueAtTime(90, 0);
            this.osc.type = 'sine';
            this.osc.start();
            this.osc.connect(this.gain);
            this.shaper.connect(this.gain); // no input by default
            this.gain.connect(this.level);
            this._updateWaveform(this.waveform);
        }
        _updateWaveform(waveform) {
            if (SynthOscNode.Waveforms.includes(waveform))
                this.waveform = waveform;
            this.osc.type = 'sine';
            if (SynthOscNode.BasicWaveforms.includes(waveform)) {
                this.osc.type = waveform;
                this.osc.disconnect();
                this.osc.connect(this.gain);
            }
            else if (SynthOscNode.PeriodicWaveforms.includes(waveform)) {
                this.osc.setPeriodicWave(this._createPeriodicWave(waveform));
                this.osc.disconnect();
                this.osc.connect(this.gain);
            }
            else if (SynthOscNode.ShaperWaveforms.includes(waveform)) {
                this.shaper.curve = this._createWaveShaper(waveform);
                this.osc.disconnect();
                this.osc.connect(this.shaper);
                if (waveform === 'pitched noise') {
                    this.osc.type = 'sawtooth';
                }
                else {
                    this.osc.type = 'sine';
                }
            }
        }
        _createWaveShaper(waveform) {
            var buffer = new Float32Array(256);
            var bufferFun; // domain & range: -1 -> 1
            switch (waveform) {
                case 'exp sin':
                    bufferFun = (x) => Math.pow(x, 5);
                    break;
                case 'hump':
                    bufferFun = (x) => (x < 0 ? 0 : x) - 0.5;
                    break;
                case 'pitched noise':
                default:
                    bufferFun = (x) => Math.random() * 2 - 1;
                    break;
            }
            for (let i = 0; i < buffer.length; i++) {
                buffer[i] = bufferFun(2 * i / buffer.length - 1);
            }
            return buffer;
        }
        _createPeriodicWave(waveform) {
            let real = new Array();
            switch (waveform) {
                // spec says real[0] is supposed to be DC offset but WebAudio ignores it >:o
                // I handle it at the end of this func with a ConstSignalNode
                case 'cello':
                    //real = [-0.15, 1, 0.5, .1, .4, .2, .3, .45, .4, .3, .125, 0.01];
                    real = [0.0, 1.0, 0.5, 0.3, 0.5, 0.35, 0.2, 0.2, .1, 0.15, 0.15, 0.15];
                    break;
                case 'flute':
                    real = [0.0, 0.5, 0.05, 0.3, 0.1];
                    break;
                case 'reed':
                    real = [-0.15, 0.5, 1.0, 0.4, 0.6, 0.3, 0.25, 0.2];
                    break;
                case 'brass':
                    real = [0.0, 0.8, 0.8, 0.85, 0.9, 0.8, 0.85, 0.7, 0.6, 0.4, 0.3, 0.25, 0.2, 0.1];
                    break;
                case 'glass':
                    real = [0.0, 1.0, 0.0, 0.25, 0.0, 0.5, 0.0, 0.75, 0.0, 0.8];
                    break;
                case 'vibraphone':
                    real = [0.0, 6, 19, 0.8, 13, 3];
                    break;
                case 'camel':
                    real.push(0);
                    for (let i = 1; i < 20; i++) {
                        real.push(1 / Math.pow(i, 2));
                    }
                    break;
                case 'soft saw': // first 20 harmoics of saw wave
                    real.push(-0.1);
                    for (let i = 1; i < 20; i++) {
                        real.push(1 / i);
                    }
                    break;
                case 'soft square':
                    real.push(0);
                    for (let i = 1; i < 50; i++) {
                        real.push(1 / i * (i % 2));
                    }
                    break;
                case 'organ 1': // these are basically drawbars...
                    real = [-0.1, 1.0, 1.0, 1.0];
                    break;
                case 'organ 2':
                    real = [-0.1, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.8];
                    break;
                case 'organ 3':
                    real = [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.8, 0.8, 0.8, 0.8];
                    break;
                case 'buzz 1':
                    real.push(0);
                    let n = 1;
                    for (let i = 1; i < 100; i++) {
                        if (i % 3 == 0 || i % 4 == 0) {
                            real.push(1.0 / n);
                            n++;
                        }
                        else {
                            real.push(0);
                        }
                    }
                    break;
                case 'buzz 2':
                default:
                    real.push(0);
                    n = 1;
                    for (let i = 1; i < 100; i++) {
                        if (i % 5 == 0 || i % 2 == 0) {
                            real.push(0.5 / n);
                            n++;
                        }
                        else {
                            real.push(0);
                        }
                    }
                    break;
            }
            return this.osc.context.createPeriodicWave(real, new Float32Array(real.length));
        }
        playNote(note) {
            let f = this.relative ? note.frequency * this.multiplier : this.frequency;
            f = clamp$1(f, 0, 23999);
            this.osc.frequency?.setValueAtTime(f, this.context.currentTime);
            this.osc.detune?.setValueAtTime(this.detune, this.context.currentTime);
        }
        scheduleNote(note, when, duration, release) {
            when = (when < 0) ? 0 : when;
            let f = this.relative ? note.frequency * this.multiplier : this.frequency;
            f = clamp$1(f, 0, 23999);
            this.osc.frequency?.setValueAtTime(f, when + this.context.currentTime);
            this.osc.detune?.setValueAtTime(this.detune, when + this.context.currentTime);
        }
        cancelNotes() {
            super.cancelNotes();
            this.osc.frequency?.cancelScheduledValues(0);
            this.osc.detune?.cancelScheduledValues(0);
        }
        destroy() {
            super.destroy();
            this.osc.stop();
            this.osc.disconnect();
            this.gain.disconnect();
            this.shaper.disconnect();
        }
        pitchBend(cents) {
            const when = this.context.currentTime;
            this.osc.detune?.setTargetAtTime(this.detune + cents, when, 0.1);
        }
        /// bend the pitch of a note by the given number of cents (hundredths of a half step)
        /// The main parameter is an array of floating-point numbers representing the curve the
        /// note will change along its duration. The specified values are spaced equally along this duration.
        ///    start - start time of the bend in seconds
        ///    cents - pitch bend value curve over time
        schedulePitchBend(start, cents) {
            cents.apply(this.osc.detune, start, this.context, this.detune);
        }
        /// update a node parameter by name
        updateParameter(pname, newValue) {
            if (pname === 'waveform') {
                this._updateWaveform(newValue);
            }
            else if (pname == 'relative') {
                this.relative = toBool(newValue, true);
            }
            else if (pname == 'frequency') {
                this.frequency = toNum(newValue, this.frequency);
                this.osc.frequency?.setValueAtTime(this.frequency, this.context.currentTime);
            }
            else if (pname == 'multiplier') {
                if (this.relative) {
                    let f = this.osc.frequency.value / this.multiplier;
                    this.multiplier = toNum(newValue, this.multiplier);
                    if (this.multiplier > 0)
                        f *= this.multiplier;
                    f = clamp$1(f, 0, 23999);
                    this.osc.frequency?.setValueAtTime(f, this.context.currentTime);
                }
                else {
                    this.multiplier = toNum(newValue, this.multiplier);
                }
            }
            else if (pname == 'detune') {
                this.detune = toNum(newValue, this.detune);
                this.osc.detune?.setValueAtTime(this.detune, this.context.currentTime);
            }
            else {
                super.updateParameter(pname, newValue);
            }
        }
    }
    SynthOscNode.BasicWaveforms = ["sine", "square", "triangle", "sawtooth"];
    SynthOscNode.PeriodicWaveforms = [
        "cello", "flute", "reed", "brass",
        "glass", "vibraphone", "camel",
        "organ 1", "organ 2", "organ 3", "soft saw", "soft square",
        "buzz 1", "buzz 2"
    ];
    SynthOscNode.ShaperWaveforms = ["pitched noise", "exp sin", "hump"];
    SynthOscNode.Waveforms = [
        ...SynthOscNode.BasicWaveforms,
        ...SynthOscNode.PeriodicWaveforms,
        ...SynthOscNode.ShaperWaveforms
    ];

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
      *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    //-----------------------------------------------------------------------
    // Out Node: Just an ADSR envelope
    //-----------------------------------------------------------------------
    class OutNode extends ADSRNode {
        constructor(context, config) {
            super(context, config);
        }
    }

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    /**
     * Loads audio files and caches them as audio buffers
     */
    class SoundLoader {
        /// creates a synthesizer with default patch
        constructor() { }
        /// returns true if the audio buffer has already been loaded
        static hasSound(name) {
            return (SoundLoader.sounds.has(name));
        }
        /// returns a preloaded audio buffer or null if it doesn't exist
        static getAudioBuffer(name) {
            return SoundLoader.sounds.get(name);
        }
        /// asynchronously loads a sound from the given URL and uses name as the hash key
        static async loadAudioBuffer(name) {
            const ctx = SoundLoader.context;
            if (SoundLoader.hasSound(name))
                return true;
            const url = SoundLoader.supportsAudioType('audio/ogg') ? `${name}.ogg` : `${name}.wav`;
            try {
                let response = await fetch(url);
                let abuff = await response.arrayBuffer();
                let buffer = await ctx.decodeAudioData(abuff);
                SoundLoader.sounds.set(name, buffer);
                return true;
            }
            catch (e) {
                console.log(e);
                return false;
            }
        }
        /// asynchronously loads a sound from the given URL and uses name as the hash key
        static async loadCustomSound(url) {
            if (SoundLoader.hasSound(url))
                return true;
            const ctx = SoundLoader.context;
            try {
                let response = await fetch(url);
                let abuff = await response.arrayBuffer();
                let buffer = await ctx.decodeAudioData(abuff);
                SoundLoader.sounds.set(url, buffer);
                console.log("Loaded " + url);
                return true;
            }
            catch (e) {
                console.log(e);
                return false;
            }
        }
        /// checks to see if a particular audio format is supported by the browser
        ///     "audio/mpeg", "audio/mp4", "audio/ogg", "audio/x-aiff", "audio/wav" 
        static supportsAudioType(mimetype) {
            if (SoundLoader._supports.has(mimetype)) {
                return SoundLoader._supports.get(mimetype);
            }
            let supportsFormat = false;
            const audio = document.createElement('audio');
            audio.id = "test-audio-node";
            document.body.append(audio);
            if (audio.canPlayType(mimetype) == "probably" || audio.canPlayType(mimetype) == "maybe") {
                supportsFormat = true;
                document.querySelector("#test-audio-node")?.remove();
            }
            SoundLoader._supports.set(mimetype, supportsFormat);
            return supportsFormat;
        }
    }
    /// global map of loaded audio buffers
    SoundLoader.sounds = new Map();
    SoundLoader.context = TunePadAudio.init().context;
    SoundLoader._supports = new Map();

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    function isPitchedSample(p) {
        return (typeof p === 'object' &&
            'sample' in p && typeof p.sample === 'string' &&
            'step' in p && typeof p.step === 'number');
    }
    //-----------------------------------------------------------------------
    // Sample Node: uses an array of samples mapped to pitches
    //-----------------------------------------------------------------------
    class SynthSampleNode extends SynthNode {
        constructor(context, config) {
            super(context, config);
            this.sources = new Array();
            /// playback rate parameter
            this.playback = 1.0;
            /// the detune parameter
            this.detune = 0.0;
            /// which built-in sample pack are we using?
            this.sample_pack = 'piano';
            this.samples = new Array();
            /// calculated playback rate based on note pitch and sample pack
            this._rate = 1.0;
            /// drumkits use different algorithm for matching notes to sounds
            this.drumkit = false;
            this.playback = toNum(config['playback'], this.playback);
            this.detune = toNum(config['detune'], this.detune);
            this.sample_pack = toStr(config['sample-pack'], this.sample_pack);
            this.dIn = new GainNode(context);
            this.pIn = new GainNode(context);
            this.dIn.gain.value = toNum(config['detune-mod'], 1.0);
            this.pIn.gain.value = toNum(config['playback-mod'], 1.0);
            if ('samples' in config && Array.isArray(config['samples'])) {
                this.loadSamplePack(config['samples']);
            }
        }
        loadSamplePack(samples) {
            this.samples = samples
                .filter(s => isPitchedSample(s))
                .sort((a, b) => a.step - b.step);
            this.samples.forEach(s => SoundLoader.loadAudioBuffer(s.sample));
        }
        static loadAudioBuffers(samples, context) {
            samples.forEach(s => SoundLoader.loadAudioBuffer(s.sample));
        }
        playNote(note) {
            this.scheduleNote(note, 0, 0, 0);
        }
        findBestSample(note) {
            let samp;
            if (this.drumkit) {
                // different from the dart implementation (!) which uses note.step
                samp = this.samples.find(s => s.step === Math.round(note.note));
            }
            else {
                let score = 100000;
                for (const s of this.samples) {
                    // perfect pitch
                    if (s.step == note.note) {
                        return s;
                    }
                    // stop searching if we're greater than the target
                    else if (s.step > note.note) {
                        const d = (s.step - note.note) + 3; // 3-step penalty for overshooting
                        return (d < score) ? s : samp;
                    }
                    // keep searching while we're below the target pitch
                    else {
                        const d = (note.note - s.step);
                        if (d < score) {
                            samp = s;
                            score = d;
                        }
                    }
                }
            }
            return samp;
        }
        scheduleNote(note, when, duration, release) {
            const offset = (when < 0) ? -when : 0;
            when = Math.max(0, when);
            const sample = this.findBestSample(note);
            if (sample) {
                const buffer = SoundLoader.getAudioBuffer(sample.sample);
                if (buffer) {
                    const delta = (note.note - sample.step);
                    const now = this.context.currentTime;
                    const pb = Math.pow(2, delta / 12);
                    const source = new AudioBufferSourceNode(this.context);
                    source.connect(this.level);
                    this.sources.push(source);
                    this.dIn.connect(source.detune);
                    this.pIn.connect(source.playbackRate);
                    source.buffer = buffer;
                    //source?.detune?.value = detune;
                    source.playbackRate.value = pb * this.playback;
                    source.start(when + now, offset);
                    if (duration > 0) {
                        source.stop(when + now + duration + release);
                    }
                    source.addEventListener('ended', (e) => {
                        this.sources = this.sources.filter((item) => item !== source);
                        // these gain nodes seem to get automatially disconnected by webaudio on end
                        //pIn.disconnect(source);
                        //dIn.disconnect(source);
                        source.disconnect();
                    });
                    buffer.duration / (pb * this.playback);
                    this._rate = pb;
                }
            }
            //return min(sampleDuration, duration);
        }
        cancelNotes() {
            super.cancelNotes();
            this.sources.forEach((source) => {
                source.stop();
                source.disconnect();
            });
            this.sources = new Array();
            this._rate = 1.0;
        }
        destroy() {
            super.destroy();
            this.sources.forEach((source) => {
                source.stop();
                source.disconnect();
            });
            this.sources = new Array();
            this._rate = 1.0;
        }
        pitchBend(cents) {
            const when = this.context.currentTime;
            this.sources.forEach((source) => {
                source.detune?.setTargetAtTime(this.detune + cents, when, 0.1);
            });
        }
        /// bend the pitch of a note by the given number of cents (hundredths of a half step)
        /// The main parameter is an array of floating-point numbers representing the curve the
        /// note will change along its duration. The specified values are spaced equally along this duration.
        ///    start - start time of the bend in seconds
        ///    cents - pitch bend value curve over time
        schedulePitchBend(start, cents) {
            if (this.sources.length > 0) {
                const last = this.sources[this.sources.length - 1];
                cents.apply(last.detune, start, this.context, this.detune);
            }
        }
        connect(source, dest) {
            if (dest == 'detune') {
                source.level.connect(this.dIn);
            }
            else if (dest == 'playback') {
                source.level.connect(this.pIn);
            }
        }
        /// update a node parameter by name
        updateParameter(pname, newValue) {
            if (pname == 'playback') {
                this.playback = toNum(newValue, this.playback);
                this.sources.forEach((source) => {
                    source.playbackRate?.setValueAtTime(this._rate * this.playback, this.context.currentTime);
                });
            }
            else if (pname == 'detune') {
                this.detune = toNum(newValue, this.detune);
                this.sources.forEach((source) => {
                    source.detune?.setValueAtTime(this.detune, this.context.currentTime);
                });
            }
            else if (pname == 'sample-pack') ;
            else if (pname == 'playback-mod') {
                this.pIn.gain.value = toNum(newValue, 1.0);
            }
            else if (pname == 'detune-mod') {
                this.dIn.gain.value = toNum(newValue, 1.0);
            }
            else {
                super.updateParameter(pname, newValue);
            }
        }
    }

    /// A synth chain is a collection of connected nodes that forms
    /// the audio processing chain defined by the synth patch config file.
    /// chains can be cached and reused
    class SynthChain {
        /// create a synth chain from a configuration patch
        constructor(context) {
            this.id = 0;
            /// time in seconds when this generator will be free for reuse
            /// * 0 means that it is free now
            this.free = 0.0;
            /// list of nodes connected to generate sounds
            this.nodes = new Map();
            /// final output gain node that will get connected to the audio destination
            this.out = null;
            /// longest release time for all of the ADSR nodes
            this.release = 0.0;
            /// handles midi note velocities
            this.gates = new Array();
            this.context = context;
            this.id = SynthChain._CHAIN_ID++;
            this.loadPatch(SynthChain._sine_patch);
        }
        playNote(note, dest) {
            const now = dest.context.currentTime;
            this.free = 365 * 24 * 60 * 60; /// 1 year in future
            this.disconnect();
            const velocity = new GainNode(dest.context);
            velocity.connect(dest);
            velocity.gain.value = note.gain;
            velocity.gain.setValueAtTime(note.gain, now);
            this.out?.level.connect(velocity);
            this.gates.push({ free: this.free, node: velocity });
            this.nodes.forEach((node, k, m) => node.playNote(note));
        }
        releaseNote() {
            this.nodes.forEach((node, k, m) => node.releaseNote());
        }
        scheduleNote(note, when, duration, dest) {
            const now = dest.context.currentTime;
            this.free = now + when + duration + this.release + 0.05;
            //-----------------------------------------------------------------
            // create a gated velocity node that is only open while the note is playing
            //-----------------------------------------------------------------
            const velocity = new GainNode(dest.context);
            velocity.connect(dest);
            velocity.gain.value = 0;
            velocity.gain?.setValueAtTime(0, 0);
            velocity.gain?.setValueAtTime(note.gain, Math.max(now, now + when));
            velocity.gain?.setValueAtTime(0, Math.max(now, now + when + duration + this.release));
            this.out?.level.connect(velocity);
            this.gates.push({ 'free': this.free, 'node': velocity });
            //print('scheduleNote at ${when.toStringAsFixed(2)} for ${duration.toStringAsFixed(2)} to be free at ${free.toStringAsFixed(2)}');
            try {
                this.nodes.forEach((node, k, m) => {
                    node.scheduleNote(note, when, duration, this.release);
                });
            }
            catch (x) {
                console.log("Note scheduling exception: $x");
            }
            //-----------------------------------------------------------------
            // free up any old velocity gates
            //-----------------------------------------------------------------
            for (let i = 0; i < this.gates.length; i++) {
                if (this.gates[i]['free'] < now) {
                    this.gates[i]['node']?.disconnect();
                    this.out?.level.disconnect(this.gates[i]['node']);
                    delete this.gates[i];
                }
            }
            this.gates = this.gates.filter(g => (typeof g !== 'undefined'));
            return this.release;
        }
        disconnect() {
            this.out?.level.disconnect();
            this.gates.forEach((gate) => { gate['node']?.disconnect(); });
            this.gates = [];
        }
        cancelNotes() {
            this.disconnect();
            this.nodes.forEach(n => n.cancelNotes());
            this.free = 0;
        }
        destroy() {
            this.disconnect();
            this.nodes.forEach(n => n.destroy());
            this.nodes.clear();
        }
        pitchBend(cents) {
            this.nodes.forEach(n => n.pitchBend(cents));
        }
        schedulePitchBend(start, curve) {
            this.nodes.forEach((node) => node.schedulePitchBend(start, curve));
        }
        loadPatch(config) {
            this.nodes.clear();
            this.out = null;
            this.release = 0.0;
            if (Array.isArray(config.nodes)) {
                for (let c of config.nodes) {
                    let node = this.createSynthNode(this.context, c);
                    if (node instanceof OutNode)
                        this.out = node;
                    this.nodes.set(node.id, node);
                }
            }
            this._updateReleaseValue();
            for (let r of config['routing']) {
                let source = this.nodes.get(r['source']);
                let dest = this.nodes.get(r['dest']);
                if (source && dest) {
                    let connector = new SynthConnector(source, r);
                    source.addConnector(connector);
                    dest.connect(connector, toStr(r['type'], ''));
                }
            }
        }
        createSynthNode(context, config) {
            switch (config.type) {
                //case 'bitcrush': return SynthBitCrushNode(context, config);
                //case 'compressor': return SynthCompressorNode(context, config);
                //case 'const': return SynthConstNode(context, config);
                //case 'distortion': return SynthDistortionNode(context, config);
                case 'gain': return new SynthNode(context, config);
                //case 'inverter': return SynthInverterNode(context, config);
                //case 'lfo':
                //    SynthOscNode lfo = SynthOscNode(context, config);
                //    lfo.gain.gain?.value = 1.0;
                //    return lfo;
                //case 'fm': return SynthOscNode(context, config);
                //case 'modal': return SynthModalNode(context, config);
                //case 'noise': return SynthNoiseNode(context, config);
                case 'osc': return new SynthOscNode(context, config);
                //case 'panner': return SynthPannerNode(context, config);
                //case 'pwm': return SynthPWMNode(context, config);
                //case 'delay': return SynthDelayNode(context, config);
                case 'adsr': return new ADSRNode(context, config);
                case 'filter': return new SynthFilterNode(context, config);
                //case 'mixer': return SynthMixNode(context, config);
                case 'out': return new OutNode(context, config);
                //case 'rand': return SynthRandomSignalNode(context, config);
                case 'sample': return new SynthSampleNode(context, config);
                case 'drums': return new SynthSampleNode(context, config);
                //case 'stereo': return SynthStereoNode(context, config);
                default:
                    console.log(`Node not found: ${config['type']}`);
                    return new SynthNode(context, config);
                //case 'phaser': return PhaserNode(context, config));
                //case 'ks': return KSNode(context, config));
                //case 'buffer source': return BufferSourceNode(context, config));
                //case 'reverb': return ReverbNode(context, config));
            }
        }
        getNodeById(id) {
            return this.nodes.get(id);
        }
        updateParameter(nodeId, pname, newValue) {
            let node = this.nodes.get(nodeId);
            node?.updateParameter(pname, newValue);
            this._updateReleaseValue();
        }
        updateConnectorLevel(nodeId, connectorId, dB) {
            let node = this.nodes.get(nodeId);
            node?.updateConnectorLevel(connectorId, dB);
        }
        attachAnalyzer(nodeId, connectorId, fftSize, channels) {
            let node = this.nodes.get(nodeId);
            node?.attachAnalyzer(connectorId, fftSize, channels);
        }
        detachAnalyzer(nodeId, connectorId) {
            let node = this.nodes.get(nodeId);
            node?.detachAnalyzer(connectorId);
        }
        getFloatTimeDomainData(nodeId, connectorId, channel, buff) {
            let node = this.nodes.get(nodeId);
            node?.getFloatTimeDomainData(connectorId, channel, buff);
        }
        _updateReleaseValue() {
            this.release = 0.0;
            this.nodes.forEach((node) => {
                if (node instanceof ADSRNode) {
                    this.release = Math.max(Math.max(node.A + node.D, node.R), this.release);
                }
            });
        }
    }
    SynthChain._CHAIN_ID = 0;
    SynthChain._sine_patch = {
        "nodes": [
            {
                "type": "out",
                "A": 0.1,
                "D": 0.1,
                "S": 0.8,
                "R": 0.15,
                "id": 0
            },
            {
                "type": "osc",
                "waveform": "sine",
                "relative": "true",
                "frequency": 1.0,
                "id": 1,
                "level": 0.1
            }
        ],
        "routing": [
            { "source": 1, "dest": 0, "type": "out" }
        ]
    };
    SynthChain._custom_patch = {
        "nodes": [
            {
                "type": "out",
                "id": 0,
                "A": 0.0,
                "D": 0.1,
                "S": 1,
                "R": 0.3,
                "level": 0
            },
            {
                "type": "sample",
                "sample-pack": "custom",
                "samples": [
                    {
                        "sample": "<SOUNDURL>",
                        "step": 60
                    }
                ],
                "id": 1,
                "level": 0
            }
        ],
        "routing": [
            { "id": 2, "source": 1, "dest": 0, "type": "audio", "level": 0 }
        ]
    };

    const DefaultEffectParams = {
        start: 0,
        beats: 0,
        values: []
    };
    /// Audio effects can be added to a synthesizer's fx "stack".
    /// Some effects get layered together in the audio chain.
    /// Other effects (after effects) are applied on top of existing
    /// SynthesizerEvents after the chain is constructed.
    class SynthEffect {
        constructor(name, oparams) {
            /// array of parameter values applied dynamically to the effect
            this.params = new Array();
            /// delayed start time of the effect in beats (0 means now)
            this.start = 0;
            /// duration of the effect in beats. a negative value indicates that this
            /// effect is constant (no dynamic changes over time)
            this.beats = -1.0;
            /// absolute time when this effect can be disconnected and discarded
            this.free = -1;
            this.id = SynthEffect._EFFECT_ID++;
            this.name = name;
            this.oparams = oparams;
            this.start = Math.max(0, oparams.start);
            this.beats = oparams.beats;
            this.free = -1;
            for (const c of oparams.values) {
                const values = Array();
                if (Array.isArray(c)) {
                    for (const val of c)
                        values.push(val);
                }
                else if (typeof c === 'number') {
                    values.push(c);
                }
                this.params.push(values);
            }
        }
        static createEffect(t, context) {
            return new EmptyEffect(context);
            /*
            switch (t['effect']) {
            case 'lowpass':
            case 'highpass':
            case 'bandpass':
            case 'notch':
                return BiquadFilter(t['effect'], t.params, context);
            case 'filter':
                return BiquadFilter('lowpass', t.params, context);
            case 'pan':
                return PanEffect(t.params, context);
            case 'gain':
                return GainEffect(t.params, context);
            case 'bend':
                return PitchBendEffect(t.params, context);
            case 'reverb':
                return ReverbEffect(t.params, context);
            default:
                return EmptyEffect(context);
            }
            */
        }
        /// connect this effect to the destination node. returns the source
        /// audio node for this effect.
        /// subclasses must override. by default this is just a bypass
        /// delta is in beats
        connect(dest, bpm, delta) {
            this.free = (delta + this.start + this.beats + 0.1) * (60 / bpm) + dest.context.currentTime;
            this.node.connect(dest);
            return this.node;
        }
        /// disconnect and dispose of the audio nodes used in this effect
        disconnect() {
            this.node.disconnect();
        }
        /// override to apply after effects to notes
        ///   gen: tone generator scheduled to play the note
        ///   noteStart: the start time of the note in beats
        ///   noteDuration: the duration of the note in beats
        ///   bpm: current tempo, used to convert beats to seconds
        ///   delta: time before the start of the next measure (in beats)
        ///      when this note is to be scheduled. if negative, it means
        ///      to skip the beginning of a loop
        afterEffect(gen, noteStart, noteDuration, bpm, delta) {
        }
        /// clamp all of the parameter values within a range
        clampParam(param, minVal, maxVal) {
            for (let i = 0; i < param.length; i++) {
                param[i] = clamp$1(param[i], minVal, maxVal);
            }
        }
    }
    /// unique id for this effect
    SynthEffect._EFFECT_ID = 0;
    class EmptyEffect extends SynthEffect {
        get node() { return this._node; }
        constructor(context) {
            super('empty', DefaultEffectParams);
            this._node = new GainNode(context);
        }
    }
    /*
    /// Standard lowpass filter. Recognizes a frequency
    /// parameter, a "Q"uality parameter, and a gain parameter
    class BiquadFilter extends Effect {

      /// filter type (e.g. "lowpass", "highpass", "bandpass", "notch")
      String type = "lowpass";

      List<num> get frequency => this.params[0];

      List<num> get Q => this.params[1];

      List<num> get gain => this.params[2];


      BiquadFilter(String name, Map<String, dynamic> oparams, BaseAudioContext context) :
      super._internal(name, oparams) {

        this.node = BiquadFilterNode(context) .. type = name;
        this.type = name;

        if (this.params.isEmpty) {
          this.params.add(<num>[]);
          this.frequency.add(1000);
        }

        if (this.params.length < 2) {
          this.params.add(<num>[]);
          this.Q.add(3);
        }

        if (this.params.length < 3) {
          this.params.add(<num>[]);
          this.gain.add(1.0);
        }

        clampParam(frequency, 10, 22050);
        if (name == "highpass" || name == "lowpass") clampParam(Q, 0.0001, 30.0);
      }


      AudioNode connect(AudioNode dest, int bpm, num delta) {
        this.free = (delta + start + beats + 0.1) * (60 / bpm) + dest.context!.currentTime!;
        node.connectNode(dest);

        AudioParam fp = (node as BiquadFilterNode).frequency!;
        AudioParam qp = (node as BiquadFilterNode).Q!;
        AudioParam gp = (node as BiquadFilterNode).gain!;

        EffectCurve fcurve = EffectCurve(frequency, beats * (60 / bpm));
        EffectCurve qcurve = EffectCurve(Q, beats * (60 / bpm));
        EffectCurve gcurve = EffectCurve(gain, beats * (60 / bpm));

        fcurve.apply(fp, (delta + start) * (60 / bpm), dest.context!);
        qcurve.apply(qp, (delta + start) * (60 / bpm), dest.context!);
        gcurve.apply(gp, (delta + start) * (60 / bpm), dest.context!);

        return node;
      }
    }


    /// Pitch bend effect
    class PitchBendEffect extends Effect {

      List<num> get values => this.params[0];

      PitchBendEffect(Map<String, dynamic> params, BaseAudioContext context)
      : super._internal('bend', params) {
        this.node = GainNode(context);
      }

      /// pitch bend is applied to notes after they have been scheduled to play
      ///   gen: tone generator scheduled to play the note
      ///   noteStart: the start time of the note in beats
      ///   noteDuration: the duration of the note in beats
      ///   bpm: current tempo, used to convert timing to seconds
      ///   delta: time before the start of the next measure (in beats)
      ///      when this note is to be scheduled. if negative, it means
      ///      to skip the beginning of a loop
      void afterEffect(SynthChain ? gen, num noteStart, num noteDuration, int bpm, num delta) {
        if (values.length == 1 && beats > 0) values.insert(0, 0.0);

        //---------------------------------------------
        // convert everything to seconds
        //---------------------------------------------
        noteStart = (noteStart + delta) * (60 / bpm);  // can be negative
        noteDuration *= (60 / bpm);
        num noteEnd = noteStart + noteDuration;
        num bendStart = (delta + start) * (60 / bpm);  // can be negative
        num bendDuration = beats * (60 / bpm);
        num bendEnd = bendStart + bendDuration;

        //---------------------------------------------
        // build effect curve and trim to fit note
        //---------------------------------------------
        EffectCurve curve = EffectCurve(values, bendDuration);
        if (noteStart > bendStart) curve.trimStart(noteStart - bendStart);
        if (noteEnd < bendEnd) curve.trimEnd(bendEnd - noteEnd);

        //---------------------------------------------
        // schedule the trimmed bend to happen
        //---------------------------------------------
        gen?.schedulePitchBend(max(noteStart, bendStart), curve);
      }
    }


    class PanEffect extends Effect {

      List<num> get values => this.params[0];


      PanEffect(Map<String, dynamic> params, BaseAudioContext context) : super._internal('pan', params) {
        this.node = StereoPannerNode(context);
        clampParam(values, -1.0, 1.0);
      }


      AudioNode connect(AudioNode dest, int bpm, num delta) {
        this.free = (delta + start + beats + 0.1) * (60 / bpm) + dest.context!.currentTime!;

        node.connectNode(dest);

        AudioParam p = (node as StereoPannerNode).pan!;
        EffectCurve curve = EffectCurve(values, beats * (60 / bpm));
        /// FIXME
        curve.apply(p, (delta + start) * (60 / bpm), dest.context!);
        return node;
      }
    }


    class GainEffect extends Effect {

      List<num> get values => this.params[0];

      GainEffect(Map<String, dynamic> params, BaseAudioContext context) : super._internal('gain', params) {
        this.node = GainNode(context);

      }


      AudioNode connect(AudioNode dest, int bpm, num delta) {
        this.free = (delta + start + beats + 0.1) * (60 / bpm) + dest.context!.currentTime!;

        node.connectNode(dest);

        AudioParam param = (node as GainNode).gain!;

        if (values.length == 1 || beats <= 0) {
          //num g = (id % 2 == 1) ? 0 : 0.25 * values[0];
          num g = values[0] * values[0];
          param.setValueAtTime(g, 0);
        } else {
          EffectCurve curve = EffectCurve(values, beats * (60 / bpm));
          // map values to gain
          for (int i=0; i<curve.curve.length; i++) {
            curve.curve[i] = (curve.curve[i] * curve.curve[i]);
          }
          curve.apply(param, (delta + start) * (60 / bpm), dest.context!);
        }

        return node;
      }
    }



    class ReverbEffect extends Effect {

      //String impulseName;

      final String impulseURL = '/assets/sounds/impulses/bright-hall.wav';

      /// wet-dry level
      List<num> get values => this.params[1];

      /// control the wet v dry level
      late GainNode wet;
      late GainNode dry;

      /// convolution node
      late ConvolverNode convolve;

      /// TODO: re-enable these as sounds built into the repo

      Map<String, int> impulseResponseMap = {
        // UI Name -> Sound recording number
        "hall": 133,
        "gallery": 134,
        "museum": 135,
        "library": 200,
        "theatre": 199,
        "underpass": 198,
        "spaceecho2": 188,
        "vintagespring": 189,
        "plateshortpcm60": 195,
        "platemediumpcm60": 194,
        "platelongpcm60": 193,
        "roomshortpcm60": 192,
        "roommediumpcm60": 191,
        "roomlongpcm60": 190,
        "voxac30regular": 196,
        "voxac30bright": 197,
      };



      ReverbEffect(Map<String, dynamic> params, BaseAudioContext context) :
      super._internal('reverb', params) {
        node = GainNode(context);
        //wet = GainNode(context);
        //dry = GainNode(context);
        //convolve = ConvolverNode(context);

        //node.connectNode(dry);
        //node.connectNode(convolve);
        //convolve.connectNode(wet);

        // impulseName = params['values'][0];
        clampParam(values, 0.0, 1.0);
      }


      AudioNode connect(AudioNode dest, int bpm, num delta) {
        this.free = (delta + start + beats + 0.1) * (60 / bpm) + dest.context!.currentTime!;
        node.connectNode(dest);

        //_connect(dest, bpm, delta); // call async version of the function
        return node;
      }

      /// disconnect and dispose of the audio nodes used in this effect
      void disconnect() {
        node.disconnect();
        //wet.disconnect();
        //dry.disconnect();
        //convolve.disconnect();
      }
    */
    /*
      Future _connect(AudioNode dest, int bpm, num delta) async {
        await Synthesizer.loadCustomSound(impulseURL, dest.context!);
        convolve.buffer = Synthesizer.getAudioBuffer(impulseURL);

        if (values.length == 1 || beats <= 0) {
          num gain = values[0] * values[0];
          wet.gain?.setValueAtTime(gain, 0);
          dry.gain?.setValueAtTime(1 - gain, 0);
        }
        else {
          EffectCurve curve = EffectCurve(values, beats * (60 / bpm));
          // map values to gain for wet and dry
          EffectCurve wetCurve = curve.map((t) => t * t);
          EffectCurve dryCurve = curve.map((t) => 1 - (t * t));

          wetCurve.apply(wet.gain!, (delta + start) * (60 / bpm), dest.context!);
          dryCurve.apply(dry.gain!, (delta + start) * (60 / bpm), dest.context!);
        }

        wet.connectNode(dest);
        dry.connectNode(dest);
      }
      */
    //}

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    function isPatch(object) {
        return (typeof object.name === 'string' &&
            object.version === '2.0' &&
            object.format === 'tunepad-patch' &&
            Array.isArray(object.nodes) &&
            Array.isArray(object.routing));
    }
    /// Generic note/audio synthesizer. The various instruments (bass, marimba,
    /// drums, guitar) use samples and modullar synthesis to generate sounds.
    class Synthesizer {
        /// tempo (beats per minute)
        get bpm() { return this._bpm; }
        set bpm(tempo) { if (!isNaN(tempo))
            this._bpm = clamp$1(tempo, 5, 300); }
        /// creates a synthesizer with default patch
        constructor() {
            this._bpm = 90;
            /// list of currently scheduled or playing notes
            this.notes = new Array();
            /// configuration settings for this synth patch
            this.patch = {
                name: 'piano',
                nodes: new Array(),
                routing: new Array()
            };
            /// name of this patch
            this.voice = 'simple sine';
            /// bank of tone generators that we can checkout to play notes
            this.bank = new Array();
            /// list of scheduled sound generators
            this.sound_gens = new Array();
            /// shortcut parameters that can be adjusted by user
            this.parameters = new Array();
            /// optional analyzer node for visualizing audio stream
            this._analyzer = null;
            this._analyzers = new Map();
            this._effects = new Array();
            this._loadPatchData(DEFAULT_PATCH, '');
        }
        /// is the synth currently playing a sound?
        get isPlaying() {
            if (this.bank.length === 0) {
                return false;
            }
            else {
                const when = this.bank[0].context.currentTime;
                for (const chain of this.bank) {
                    if (chain.free > when)
                        return true;
                }
                return false;
            }
        }
        /// play and hold a note until releaseNote is called
        ///   note: note to be played (pitch and duration)
        ///   dest: ultimate audio destination
        playNote(note, dest) {
            if (!dest) {
                const audio = TunePadAudio.init();
                dest = audio.context.destination;
            }
            let generator = this._allocateGenerator(dest.context, dest.context.currentTime);
            if (generator == null)
                return null;
            generator.cancelNotes();
            generator.playNote(note, dest);
            const event = new SynthEvent(note, generator);
            this.notes.push(event);
            return event;
        }
        /// play and hold a custom sound until releaseNote is called
        ///   note: note to be played (pitch and duration)
        ///   dest: ultimate audio destination
        /*
        playSound(note : Note, soundURL : string, dest : AudioNode) : SynthEvent {
            const generator = new SynthChain.sound(dest.context, soundURL);
            generator.playNote(note, dest);
            const event = new SynthEvent(note, generator);
            this.notes.push(event);
            return event;
        }
        */
        /// schedule a note to be played in the future
        ///   note: note to be played (pitch and duration)
        ///   dest: ultimate audio destination
        ///   start: the start time for the note in beats
        ///   delta: time before the start of the next measure (in beats)
        ///          when this note is to be scheduled. if negative, it means
        ///          to skip the beginning of a loop
        scheduleNote(note, dest, start, delta = 0) {
            // convert from beats to seconds
            const now = dest.context.currentTime;
            const duration = note.duration * (60 / this.bpm);
            start = (start + delta) * (60 / this.bpm);
            // allocate generator that's free at the note start time
            const generator = this._allocateGenerator(dest.context, now + start);
            generator?.scheduleNote(note, start, duration, dest);
            return generator;
        }
        /**
            scheduleSound(note: Note, soundURL: string, dest: AudioNode, start: number, delta: number = 0): SynthChain | null {
                const now = dest.context.currentTime;
                const duration = note.duration * (60 / this.bpm);
                start = (start + delta) * (60 / this.bpm);
        
                const generator = SynthChain.sound(dest.context!, soundURL);
                const release = generator.scheduleNote(note, start, duration, dest);
                this.sound_gens.push(generator);
                return generator;
            }
        */
        /// release a sustained note event
        release(event) {
            if (event.released)
                return;
            event.released = true;
            event.chain.releaseNote();
            const timeout = Math.ceil(event.chain.release * 1000) + 100;
            setTimeout(() => {
                this.notes = this.notes.filter((e) => e !== event);
                event.chain.disconnect();
                this._releaseGenerator(event.chain);
            }, timeout);
        }
        releaseNote(note) {
            this.notes.forEach((event) => {
                if (event.note.note == note.note) {
                    this.release(event);
                }
            });
        }
        /// immediately release all notes that are currently being sustained
        releaseAll() {
            this.notes.forEach((event) => { this.release(event); });
        }
        /// cancel all scheduled notes
        cancelAllNotes() {
            for (const chain of this.bank) {
                this._releaseGenerator(chain);
            }
            for (const chain of this.sound_gens) {
                chain.cancelNotes();
            }
            this.sound_gens = [];
        }
        /// batch schedule notes and effects using an audio trace
        ///   dest: ultimate audio destination
        ///   start: the start time for the note in beats
        ///   delta: time before the start of the next measure (in beats)
        ///          when this note is to be scheduled. if negative, it means
        ///          to skip the beginning of a loop
        scheduleNotes(trace, dest, delta) {
            const now = dest.context.currentTime;
            const offset = Math.max(0, -delta);
            //-------------------------------------------------
            // cleanup old effects
            //-------------------------------------------------
            for (let i = 0; i < this._effects.length; i++) {
                const fx = this._effects[i];
                if (fx.free > 0 && fx.free < now) {
                    fx.disconnect();
                    delete this._effects[i];
                }
            }
            this._effects = this._effects.filter(e => (typeof e !== 'undefined'));
            //-------------------------------------------------
            // cleanup previously scheduled sound generators
            //-------------------------------------------------
            for (let i = 0; i < this.sound_gens.length; i++) {
                const chain = this.sound_gens[i];
                if (chain.free < now) {
                    delete this.sound_gens[i];
                }
            }
            this.sound_gens = this.sound_gens.filter(e => (typeof e !== 'undefined'));
            //-------------------------------------------------
            // schedule new notes
            //-------------------------------------------------
            const estack = new Array();
            const rootFx = new EmptyEffect(dest.context);
            rootFx.beats = trace.beats;
            estack.push(rootFx);
            this._effects.push(rootFx);
            rootFx.connect(dest, this.bpm, delta);
            for (const t of trace.trace) {
                if (t.command == TraceEvent.PUSH_FX) {
                    // TODO: don't allow duplicate effects in the stack?
                    const parent = estack[estack.length - 1];
                    const fx = SynthEffect.createEffect(t, dest.context);
                    fx.connect(parent.node, this.bpm, delta);
                    estack.push(fx);
                    this._effects.push(fx);
                }
                else if (t.command == TraceEvent.POP_FX) {
                    estack.pop();
                }
                else if (t.command == TraceEvent.PLAY && t.end >= offset) {
                    const last = estack[estack.length - 1];
                    const gen = this.scheduleNote(t.note, last.node, t.time, delta);
                    estack.forEach((fx) => {
                        fx.afterEffect(gen, t.time, t.note.duration, this.bpm, delta);
                    });
                }
                /*
                else if (t.command == TraceEvent.SOUND && t.end >= offset && t['sound-url'] is String) {
                    const gen = scheduleSound(t.note, t['sound-url'], estack.last.node, t.time, delta);
                    estack.forEach((fx) { fx.afterEffect(gen, t.time, t.note.duration, bpm, delta); });
                }
                */
            }
        }
        /**
         * Experimental. Generate MIDI output events
         * @param trace
         * @param delta time before the start of the next measure (in beats)
         * when this note is to be scheduled. if negative, skip the beginning of a loop
         * @param port which MIDIOutput port to send messages to
         * @param gain adjust output velocity of all notes (number >= 0.0)
         */
        scheduleMidiNotes(trace, delta, port, gain = 1.0) {
            const now = window.performance.now();
            const offset = Math.max(0, -delta);
            for (const t of trace.trace) {
                if (t.command === TraceEvent.PLAY && t.end >= offset) {
                    const note = t.note.clone();
                    note.gain *= gain;
                    // convert from beats to milliseconds
                    const duration = t.note.duration * (60 / this.bpm) * 1000;
                    const start = now + (t.time + delta) * (60 / this.bpm) * 1000;
                    const noteOn = [0x90, Math.round(note.note), note.velocity];
                    const noteOff = [0x80, Math.round(note.note), 0];
                    port.send(noteOn, start);
                    port.send(noteOff, start + duration);
                }
            }
        }
        /**
         * Sets the MIDI output "program" or instrument voice
         */
        setMidiProgram(port, voice) {
            if (voice >= 0 && voice <= 0x7f) {
                port.send([0xC0, voice]);
            }
        }
        /**
         * Send noteOff to all possible midi note values
         */
        cancelAllMidiNotes(port) {
            const now = window.performance.now();
            for (let note = 0; note <= 0x7f; note++) {
                port.send([0x80, note, 0], now);
            }
            if ("clear" in port && typeof port['clear'] === 'function') {
                port.clear();
            }
        }
        /// set the pitch bend "wheel" to the given number of cents.
        /// this only applies to currently scheduled or playing notes.
        pitchBend(cents) {
            this.notes.forEach((event) => event.chain.pitchBend(cents));
        }
        /**
         * URL should point to a JSON file with patch details.
         * Links to audio samples in a patch will be relative to the URL path
         * After loading the JSON object, sets up audio nodes and loads all audio resources
         *
         * If the URL ends with a '/' then 'patch.json' will be appended.
         */
        async loadPatch(url) {
            try {
                if (url.endsWith('/'))
                    url += 'patch.json';
                let response = await fetch(url);
                let json = await response.json();
                if (isPatch(json)) {
                    return await this._loadPatchData(json, url);
                }
            }
            catch (e) {
                console.log("Failed to load audio patch.", e);
            }
            finally {
                return false;
            }
            /*
            for (const config of patch['parameters']) {
                this.parameters.push(SynthParameter.fromJSON(config));
            }
            */
        }
        async _loadPatchData(json, url) {
            const path = url.split('/').slice(0, -1).join('/') + "/";
            this.voice = json.name;
            this.patch = json;
            this.parameters = [];
            this._destroyAllGenerators();
            this.sound_gens = [];
            for (const node of this.patch.nodes) {
                if (Array.isArray(node["samples"])) {
                    const samples = node['samples']
                        .filter(s => isPitchedSample(s))
                        .sort((a, b) => a.step - b.step);
                    samples.forEach(s => {
                        s.sample = path + s.sample;
                        SoundLoader.loadAudioBuffer(s.sample);
                    });
                    node['samples'] = samples;
                }
                else if (node['type'] === 'reverb') {
                    await SoundLoader.loadCustomSound(node['impulse']);
                }
                else if (node['type'] === 'buffer source') {
                    await SoundLoader.loadCustomSound(node['buffer']);
                }
            }
            return true;
        }
        /// return a synthesizer node (modular synth node) matching the given
        /// node id number. node from the first tone generator will be used.
        /// return null if there are not tone generators or no matching nodes
        getNodeById(id) {
            return (this.bank.length > 0) ? this.bank[0]?.getNodeById(id) : undefined;
        }
        /// update parameter value for a node in all tone generators
        updateParameter(nodeId, pname, value) {
            /// update any node instances in active tone generators
            this.bank.forEach((chain) => { chain.updateParameter(nodeId, pname, value); });
            /// update the patch itself to match the new parameter value
            for (const node of this.patch.nodes) {
                if (node['id'] == nodeId)
                    node[pname] = value;
            }
        }
        /*

      /// update connector gain level
      void updateConnectorLevel(int nodeId, int connectorId, num dB) {
        bank.forEach((chain) { chain.updateConnectorLevel(nodeId, connectorId, dB); });
        if (patch['routing'] is List) {
          for (Map conn in patch['routing']) {
            if (conn['id'] == connectorId) {
              conn['level'] = dB;
            }
          }
        }
      }


      /// ask the synthesizer to keep analyzer nodes attached to the given node connector
      void attachAnalyzer(int nodeId, int connectorId, int fftSize, int channels) {
        _analyzers[connectorId] = {
          'nodeId' : nodeId,
          'connectorId' : connectorId,
          'fftSize' : fftSize,
          'channels' : channels
        };
      }

      void detachAnalyzer(int nodeId, int connectorId) {
        bank.forEach((chain) { chain.detachAnalyzer(nodeId, connectorId); });
        _analyzers.remove(connectorId);
      }


      /// collects time domain data from all attached analyzers at the given connector
      void getFloatTimeDomainData(int nodeId, int connectorId, int channel, Float32List buff) {
        buff.fillRange(0, buff.length, 0);  // zero out list
        bank.forEach((chain) {
          if (chain.free > 0) {
            chain.getFloatTimeDomainData(nodeId, connectorId, channel, buff);
          }
        });
      }
    */
        /// checkout a tone generator to play a sound
        _allocateGenerator(context, when) {
            if (this.bank.length > 0 && this.bank[0].context != context) {
                this._destroyAllGenerators();
            }
            for (const chain of this.bank) {
                if (chain.free < when && chain.context == context) {
                    this._analyzers.forEach((m) => {
                        if (chain.free == 0) {
                            chain.attachAnalyzer(m['nodeId'], m['connectorId'], m['fftSize'], m['channels']);
                        }
                    });
                    return chain;
                }
            }
            if (this.bank.length < Synthesizer.MAX_GENERATORS) {
                const chain = new SynthChain(context);
                chain.loadPatch(this.patch);
                this.bank.push(chain);
                this._analyzers.forEach((a) => {
                    chain.attachAnalyzer(a['nodeId'], a['connectorId'], a['fftSize'], a['channels']);
                });
                return chain;
            }
            else {
                return undefined;
            }
        }
        _releaseGenerator(generator) {
            generator.cancelNotes();
            this._analyzers.forEach((m) => {
                generator.detachAnalyzer(m['nodeId'], m['connectorId']);
            });
        }
        _destroyAllGenerators() {
            this.bank.forEach((chain) => { chain.destroy(); });
            this.bank = [];
        }
    }
    /// allow a maximum of 24 simultaneous notes
    Synthesizer.MAX_GENERATORS = 24;
    const DEFAULT_PATCH = {
        "uid": "66102800-408c-1eff-a707-77ec94865b87",
        "nodes": [
            {
                "type": "out",
                "A": 0.05,
                "D": 0.1,
                "S": 0.8,
                "R": 0.25,
                "level": 0,
                "id": 0
            },
            {
                "type": "osc",
                "waveform": "sine",
                "relative": "true",
                "frequency": 1.0,
                "id": 1,
                "level": 0.1
            }
        ],
        "routing": [
            { "source": 1, "dest": 0, "type": "audio", "level": 0, "id": 1 }
        ],
        "parameters": [],
        "name": "Simple Sine",
        "description": "",
        "instrument": "piano",
        "submenu": "",
        "version": "2.0",
        "format": "tunepad-patch",
        "created": "2024-03-08 16:15:54.384",
        "modified": "2024-03-08 16:15:54.385"
    };

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
      *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    /**
     * This class maintains an asynchronous request queue to generate audio buffers.
     * This creates an abstraction layer around the synthesizer.
     * By using a queue, it means we're only doing one offline audio context render at a time.
     * This improves performance and makes loading much smoother.
     * One issue with OfflineAudioContext is that it can't be cancelled once a render starts.
     * This is a huge problem because audio rendering can take seconds or minutes to render
     * with complex synthesizers or effects. We allow for chunking audio into smaller parts
     * if the goal is to create a waveform visualization.
     */
    class AudioLoadingService {
        constructor() {
            /// used to render audio buffers
            this.synth = new Synthesizer();
            /// queue for audio render requests
            this.queue = [];
            /// cache of previously rendered audio
            this.cache = new Map();
            setTimeout(() => this._processReqest(), 100);
        }
        static init() {
            if (!AudioLoadingService.instance) {
                AudioLoadingService.instance = new AudioLoadingService();
            }
            return AudioLoadingService.instance;
        }
        /**
         * Requests offline audio render of the given resource.
         */
        static requestAudioBuffer(request) {
            const service = AudioLoadingService.init();
            return new Promise((success) => {
                const cached = service.cache.get(request.uuid);
                if (cached) {
                    success(cached);
                }
                else {
                    request._callback = success;
                    service.queue.push(request);
                }
            });
        }
        static cancelRequest(uuid) {
            const service = AudioLoadingService.init();
            service.queue = service.queue.filter(r => r.uuid !== uuid);
        }
        static clearCache() {
            AudioLoadingService.instance?.cache.clear();
        }
        static clearCacheEntry(uuid) {
            AudioLoadingService.instance?.cache.delete(uuid);
        }
        async _processReqest() {
            // unpack first request on the queue
            const r = this.queue.shift();
            if (r) {
                const cached = this.cache.get(r.uuid);
                if (cached && r._callback) {
                    r._callback(cached);
                }
                else if (r.beats <= 0) {
                    const gab = new GrowableAudioBuffer();
                    this.cache.set(r.uuid, gab);
                    if (r._callback)
                        r._callback(gab);
                }
                else {
                    const gab = await this.recordIntoBuffer(r);
                    this.cache.set(r.uuid, gab);
                    if (r._callback)
                        r._callback(gab);
                }
            }
            setTimeout(() => this._processReqest(), 100);
        }
        /**
         * Render audio into a buffer using an offline audio context.
         * Beats must be greater than zero.
         */
        async recordIntoBuffer(request) {
            return new Promise(async (success) => {
                const start = request.start ? request.start : 0;
                const duration = request.beats * (60 / request.bpm);
                const rate = 44100;
                const channels = 2;
                const frames = Math.round(rate * duration);
                // holds the resulting recording
                const gab = new GrowableAudioBuffer(channels, rate);
                // create offline audio context (stereo @ 44.1k sample rate)
                const oac = new OfflineAudioContext(channels, frames, rate);
                // audio worklet builds incremental waveform and reports on progress
                await oac.audioWorklet.addModule('/js/AudioWorklets.js');
                const recorder = new AudioWorkletNode(oac, "progress-monitor");
                let last_progress = 0.0;
                // build incremental waveform while rendering...
                const waveform = new WaveformData();
                // as audio renders, our reporter node will send periodic updates
                recorder.port.onmessage = (e) => {
                    const complete = e.data[2] / frames;
                    if (request.waveform)
                        waveform.appendSample(e.data);
                    if (complete > last_progress + 0.05) {
                        request.progress(Math.min(1.0, complete));
                        if (request.waveform)
                            request.waveform(waveform);
                        last_progress = complete;
                    }
                };
                recorder.connect(oac.destination);
                // configure the synth
                this.synth.bpm = request.bpm;
                await this.synth.loadPatch(request.patch);
                //await _loadCustomSounds(r);  // FIXME
                // record into the context
                this.synth.scheduleNotes(request.trace, recorder, start);
                const recording = await oac.startRendering();
                gab.appendAudioBuffer(recording);
                if (request.waveform) {
                    request.waveform(waveform);
                }
                request.progress(1.0);
                success(gab);
            });
        }
    }

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    /**
     * Playable piano keyboard with note names and numbers.
     * Octave buttons.
     *
     * <piano-instrument
     *      patch="/assets/voices/grand-piano/">
     *      note-hints = "true"   // show note names on keys
     *      midi-hints = "true"   // show midi note numbers on keys
     *      armed = "false"       // listen for keyboard events
     *      min-octave = "0"      // lowest octave available
     *      max-octave = "7"      // highest octave available
     *      key-range = "28"      // how many keys to show at one time
     *      focus-octave = "3">   // focus (left-most) octave showing
     * </piano-instrument>
     */
    class Piano extends HTMLElement {
        constructor() {
            super();
            // create a synthesizer and load a grand piano
            this.synth = new Synthesizer();
            this.octave = 3;
            this.minOctave = 0;
            this.maxOctave = 7;
            this.root = this.attachShadow({ mode: 'open' });
            this.root.adoptedStyleSheets.push(stylesheet$a);
            const template = document.createElement('template');
            template.innerHTML = html$7;
            // Create a shadow root
            this.root.appendChild(template.content.cloneNode(true));
            this.keyboard = this.root.querySelector('piano-keyboard');
            this.audio = TunePadAudio.init();
        }
        connectedCallback() {
            // create the audio context
            this.audio = TunePadAudio.init();
            // catch piano note events and play note + display note info
            this.keyboard.addEventListener('note-on', (e) => {
                const note = new Note(e.detail.note);
                this.synth.playNote(note, this.audio.context.destination);
            });
            this.keyboard.addEventListener('note-off', (e) => {
                const note = new Note(e.detail.note);
                this.synth.releaseNote(note);
            });
            this.root.querySelector('#down-octave')?.addEventListener('click', (e) => {
                this.octave = Math.max(this.minOctave, this.octave - 1);
                this.root.querySelector('piano-keyboard')?.setAttribute('focus-octave', `${this.octave}`);
            });
            this.root.querySelector('#up-octave')?.addEventListener('click', (e) => {
                this.octave = Math.min(this.maxOctave, this.octave + 1);
                this.root.querySelector('piano-keyboard')?.setAttribute('focus-octave', `${this.octave}`);
            });
        }
        disconnectedCallback() {
            //console.log("Custom element removed from page.");
        }
        attributeChangedCallback(name, oldValue, newValue) {
            if (name === 'patch' && newValue !== oldValue) {
                this.synth.loadPatch(newValue);
            }
            else if (newValue !== oldValue) {
                this.keyboard.setAttribute(name, newValue);
            }
            if (name === 'focus-octave') {
                this.octave = parseInt(newValue);
            }
            else if (name === 'min-octave') {
                this.minOctave = parseInt(newValue);
            }
            else if (name === 'max-octave') {
                this.maxOctave = parseInt(newValue);
            }
            this.octave = isNaN(this.octave) ? 3 : this.octave;
            this.minOctave = isNaN(this.minOctave) ? 0 : this.minOctave;
            this.maxOctave = isNaN(this.maxOctave) ? 7 : this.maxOctave;
        }
    }
    Piano.ELEMENT = "piano-instrument";
    Piano.observedAttributes = [
        ...PianoKeyboard.observedAttributes,
        "patch", // URL for patch JSON file
    ];

    const stylesheet$9 = new CSSStyleSheet();
    stylesheet$9.replaceSync(`:host {
    --error-red: #da575d;
    --warn-yellow: orange;
    --output-green: #87c44e;
 }

.code-view-wrapper {
    margin: 2rem 0;
    border-radius: 0.75em;
    overflow: hidden;
    max-width: 700px;
    position: relative;
    background-color: #e3e9f2;
}

.code-view-wrapper.light {
    background-color: #e3e9f2;
}

.buttons {
    position: absolute;
    right: 0;
    top: 0;
    z-index: 5;
    margin: 0.75rem;
}

.buttons button {
    width: 30px;
    height: 30px;
    line-height: 20px;
    outline: none;
    border: none;
    background: transparent;
    color: #666;
    padding: 4px;
}
.buttons button svg { 
    width: 15px; 
    height: 15px; 
    fill: #666;
    vertical-align: middle;
}

.buttons button:hover { color: black; }
.buttons button:hover svg { fill: black; }

.buttons button:active { color: var(--highlight-color); }
.buttons button:active svg { fill: var(--highlight-color); }
.buttons button.hidden { display: none; }

#loader svg {
    animation: spin-animation 2s infinite;
    animation-timing-function: linear;
}

pre[class*="language-python"] {
    padding-left: 0.5em;
    font-size: 12px;
}

code[class*="language-python"] {
    line-height: 1.75;
}

pre[class*="language-"].line-numbers {
	position: relative;
	padding-left: 3.8em;
    margin: 0;
	counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
	position: relative;
	white-space: inherit;
}

.line-numbers .line-numbers-rows {
	position: absolute;
	pointer-events: none;
	top: -2px;
	font-size: 100%;
	left: -3.8em;
	width: 3em; /* works for line-numbers below 1000 lines */
	letter-spacing: -1px;
	border-right: 1px solid #999;
	user-select: none;
	background-color: transparent;
}

.line-numbers-rows > span {
    display: block;
    counter-increment: linenumber;
}

.line-numbers-rows > span:before {
    content: counter(linenumber);
    color: #999;
    display: block;
    padding-right: 0.8em;
    text-align: right;
}

footer {
    background-color: #777;
    color: white;
    font-size: 12px;
    padding: 0.4em 2em;
    display: flex;
}

footer.error {
    background-color: #aa3e3e;
}

footer div {
    margin-left: 1.5rem;
}

footer div:first-child {
    margin-left: 0;
}
#status, #error { flex: 1; }

footer #error { display: none; }
footer.error div { display: none; }
footer.error div#error { display: block; }

.progress-bar {
    display: block;
    height: 5px;
    width: 100%;
    background-color: #0002;
}
.progress-bar.hidden { display: none; }

.progress-bar .fill {
    background-color: cornflowerblue;
    height: 100%;
    margin: 0;
    padding: 0;
    width: 0%;
}

@media print {
    footer { display: none; }
    .buttons { display: none; }
    pre[class*="language-python"] { font-size: 10px; }
    .code-view-wrapper {
        border: 1px solid #0005;
        max-width: 550px;
    }
}

@keyframes spin-animation {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(359deg);
    }
}
`);

    const stylesheet$8 = new CSSStyleSheet();
    stylesheet$8.replaceSync(`code[class*=language-],pre[class*=language-]{color:#111b27;background:0 0;font-family:Consolas,Monaco,"Andale Mono","Ubuntu Mono",monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{background:#ccd6e4}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{background:#ccd6e4}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#e3e9f2}:not(pre)>code[class*=language-]{padding:.1em .3em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#304259;font-style:italic}.token.punctuation{color:#111b27}.token.selector,.token.tag{color:#007474}.token.attr-name,.token.boolean,.token.constant,.token.number,.token.pseudo-class,.token.pseudo-element,.token.selector .token.attribute{color:#7d6600}.token.class-name,.token.key,.token.parameter,.token.property,.token.property-access,.token.variable{color:#005c99}.token.attr-value,.token.color,.token.inserted,.token.selector .token.value,.token.string,.token.string .token.url-link{color:#237800}.token.builtin,.token.keyword-array,.token.package,.token.regex{color:#b800b8}.token.function,.token.selector .token.class,.token.selector .token.id{color:#8600c6}.token.atrule .token.rule,.token.combinator,.token.keyword,.token.operator,.token.unit{color:#aa4d00}.token.deleted,.token.important{color:#bf0100}.token.keyword-this,.token.this{color:#005c99}.token.bold,.token.important,.token.keyword-this,.token.this{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.language-markdown .token.title,.language-markdown .token.title .token.punctuation{color:#005c99;font-weight:700}.language-markdown .token.code{color:#007474}.language-markdown .token.url>.token.content{color:#237800}.language-markdown .token.url-link{color:#7d6600}.language-markdown .token.list.punctuation{color:#b800b8}.language-markdown .token.table-header{color:#111b27}.language-json .token.operator{color:#111b27}.token.cr:before,.token.lf:before,.token.space:before,.token.tab:not(:empty):before{color:#304259}div.code-toolbar>.toolbar a,div.code-toolbar>.toolbar button{color:#e3e9f2;background:#005c99}div.code-toolbar>.toolbar a:focus,div.code-toolbar>.toolbar a:hover,div.code-toolbar>.toolbar button:focus,div.code-toolbar>.toolbar button:hover{color:#e3e9f2;background:#005c99da;text-decoration:none}div.code-toolbar>.toolbar span,div.code-toolbar>.toolbar span:focus,div.code-toolbar>.toolbar span:hover{color:#e3e9f2;background:#304259}.line-highlight{background:#3042591f;background:linear-gradient(to right,#3042591f 70%,#30425915)}.line-highlight:before,.line-highlight[data-end]:after{background-color:#304259;color:#e3e9f2;box-shadow:0 1px #ccd6e4}pre[id].linkable-line-numbers span.line-numbers-rows>span:hover:before{background-color:#3042591f}.line-numbers .line-numbers-rows{border-right:1px solid #111b271f;background:#d8e0ebda}.line-numbers-rows>span:before{color:#111b2796}.rainbow-braces .token.punctuation.brace-level-1,.rainbow-braces .token.punctuation.brace-level-5,.rainbow-braces .token.punctuation.brace-level-9{color:#7d6600}.rainbow-braces .token.punctuation.brace-level-10,.rainbow-braces .token.punctuation.brace-level-2,.rainbow-braces .token.punctuation.brace-level-6{color:#b800b8}.rainbow-braces .token.punctuation.brace-level-11,.rainbow-braces .token.punctuation.brace-level-3,.rainbow-braces .token.punctuation.brace-level-7{color:#005c99}.rainbow-braces .token.punctuation.brace-level-12,.rainbow-braces .token.punctuation.brace-level-4,.rainbow-braces .token.punctuation.brace-level-8{color:#8600c6}pre.diff-highlight>code .token.deleted:not(.prefix),pre>code.diff-highlight .token.deleted:not(.prefix){background-color:#bf01001f}pre.diff-highlight>code .token.inserted:not(.prefix),pre>code.diff-highlight .token.inserted:not(.prefix){background-color:#2378001f}.command-line-prompt{border-right:1px solid #111b271f}.command-line-prompt>span:before{color:#111b2796}`);

    var html$6 = "<div class=\"code-view-wrapper\">\n    <div class=\"buttons\">\n        <button id=\"loader\" class=\"hidden\" title=\"Loading audio\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                <path d=\"M304 48a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zm0 416a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM48 304a48 48 0 1 0 0-96 48 48 0 1 0 0 96zm464-48a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM142.9 437A48 48 0 1 0 75 369.1 48 48 0 1 0 142.9 437zm0-294.2A48 48 0 1 0 75 75a48 48 0 1 0 67.9 67.9zM369.1 437A48 48 0 1 0 437 369.1 48 48 0 1 0 369.1 437z\"/>\n            </svg>\n        </button>\n        <button id=\"play-button\" class=\"hidden\" title=\"Play Audio\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\">\n                <path d=\"M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z\"/>\n            </svg>\n        </button>\n        <button id=\"pause-button\" class=\"hidden\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 320 512\">\n                <path d=\"M48 64C21.5 64 0 85.5 0 112V400c0 26.5 21.5 48 48 48H80c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H48zm192 0c-26.5 0-48 21.5-48 48V400c0 26.5 21.5 48 48 48h32c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H240z\"/>\n            </svg>\n        </button>\n        <button id=\"stop-button\" class=\"hidden\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\">\n                <path d=\"M0 128C0 92.7 28.7 64 64 64H320c35.3 0 64 28.7 64 64V384c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V128z\"/>\n            </svg>\n        </button>\n        <button id=\"copy-button\" title=\"Copy to Clipboard\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 448 512\">\n                <path d=\"M384 336H192c-8.8 0-16-7.2-16-16V64c0-8.8 7.2-16 16-16l140.1 0L400 115.9V320c0 8.8-7.2 16-16 16zM192 384H384c35.3 0 64-28.7 64-64V115.9c0-12.7-5.1-24.9-14.1-33.9L366.1 14.1c-9-9-21.2-14.1-33.9-14.1H192c-35.3 0-64 28.7-64 64V320c0 35.3 28.7 64 64 64zM64 128c-35.3 0-64 28.7-64 64V448c0 35.3 28.7 64 64 64H256c35.3 0 64-28.7 64-64V416H272v32c0 8.8-7.2 16-16 16H64c-8.8 0-16-7.2-16-16V192c0-8.8 7.2-16 16-16H96V128H64z\"/>\n            </svg>\n        </button>\n    </div>\n    <pre class=\"line-numbers\"><code id=\"code-view\" class=\"language-python\"></code></pre>\n    <div class=\"progress-bar\"><div class=\"fill\"></div></div>\n    <footer>\n        <div id=\"status\"></div>\n        <div id=\"error\"></div>\n        <div id=\"beats\"></div>\n        <div id=\"tempo\"></div>\n        <div id=\"time\"></div>\n        <div id=\"patch\"></div>\n    </footer>\n</div>\n";

    /*
     * TunePad
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    /**
     * TypeScript facing interface for Pyodide. The actual pyodide runtime is
     * loaded in a web worker (/assets/js/PythonWorker.js)
     */
    class PythonRuntime {
        /// start the single python runtime
        /// safe to call multiple times
        static init() {
            if (PythonRuntime.instance === null) {
                PythonRuntime.instance = new PythonRuntime();
            }
            return PythonRuntime.instance;
        }
        /// private constructor for singleton pattern
        constructor() {
            /// waiting list for python compile requests
            this.queue = new Array();
            /// keeps track of previously compiled results
            this.cache = new Map();
            /// list of all python cells in a playbook known to the runtime
            this.modules = new Map();
            /// current request being processed
            this.active = null;
            /// current list of dependency warnings
            this.warnings = new Array();
            /// list of callbacks listening for warnings
            this.listeners = new Map();
            /// used to send keyboard interrupt signals to Pyodide in case of an infinite loop
            //private interruptBuffer = new Uint8Array(new SharedArrayBuffer(1));
            // FIXME: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer#security_requirements
            // SharedArrayBuffer constructor is unavailable due to security reasons, so this 
            // doesn't currently work.
            this.interruptBuffer = new Uint8Array(1);
            this.worker = new Worker("/assets/js/PythonWorker.js");
            // set up the interrupt buffer
            this.worker.postMessage({ action: "setInterruptBuffer", buffer: this.interruptBuffer });
            // service any pending runtime requests in our queue
            setTimeout(() => { PythonRuntime.instance?.processQueue(); }, 50);
            // convert worker responses into CompileResponse objects and send to callbacks
            this.worker.onmessage = (event) => {
                const data = event.data;
                const request = this.active;
                // preload response gets processed with no extra information
                if (request?.action === 'preload' && data) {
                    request.callback(new CompileResponse(request));
                }
                else if (request && request.uuid === data.uuid) {
                    // have any newer requests with updated code been added?
                    // if so, throw away this request
                    for (let r of this.queue) {
                        if (r.uuid === request.uuid && r.action === request.action && r.code !== request.code) {
                            this.active = null;
                            return;
                        }
                    }
                    let response = new CompileResponse(request);
                    response.output = data.output;
                    response.globals = data.globals;
                    response.errors = data.errors;
                    response.dependencies = data.dependencies;
                    // clear warnings for this cell
                    this.warnings = this.warnings
                        .filter((w) => (w.target !== response.uuid) && (w.source !== response.uuid));
                    // cell updated dependency warnings
                    for (const [key, resp] of this.cache) {
                        if (key !== response.uuid && resp.dependencies.includes(response.name)) {
                            this.warnings.push({
                                name: "Dependency Warning",
                                message: `Cell '${response.name}' has been updated.`,
                                details: "", line: -1,
                                target: resp.uuid,
                                source: response.uuid
                            });
                        }
                    }
                    // cell renamed dependency warnings
                    for (let [key, resp] of this.cache) {
                        if (key === response.uuid)
                            continue;
                        for (let dep of resp.dependencies) {
                            let resolved = (dep === response.name);
                            for (let [key2, resp2] of this.cache) {
                                if (key !== key2 && resp2.name === dep) {
                                    resolved = true;
                                }
                            }
                            if (!resolved) {
                                this.warnings.push({
                                    name: "Dependency Warning",
                                    message: `Cell '${dep}' does not exist.`,
                                    details: "", line: -1,
                                    target: resp.uuid,
                                    source: response.uuid
                                });
                            }
                        }
                    }
                    // provide tunepad trace object
                    if (response.globals.has('__tunepad_trace')) {
                        response.trace.fromPython(response.globals.get('__tunepad_trace').value);
                    }
                    // cache result of compile
                    if (response.hasNoErrors) {
                        this.cache.set(response.uuid, response);
                    }
                    // callback
                    request.callback(response);
                    // send out warnings
                    this.listeners.forEach((callback, uuid) => {
                        callback(this.warnings.filter((w) => w.target === uuid));
                    });
                }
                this.active = null;
            };
        }
        /// should be called when parent component unmounts
        static destroy() {
            if (PythonRuntime.instance) {
                const rt = PythonRuntime.instance;
                rt.worker.terminate();
                rt.active = null;
                rt.cache.clear();
                rt.modules.clear();
            }
        }
        /// Schedule a python compile
        /// If force is true, force a recompile even if the code hasn't changed
        static compile(cell, force = false) {
            return new Promise((callback) => {
                PythonRuntime.instance?.queue.push(new CompileRequest(cell, "compile", callback, force));
            });
        }
        /** To rename a cell we just call compile */
        static renameCell(cell) {
            return PythonRuntime.compile(cell, true);
        }
        /// Run code after compiling (e.g. event handler or unit test)
        static run(cell) {
            return new Promise((callback) => {
                PythonRuntime.instance?.queue.push(new CompileRequest(cell, "run", callback));
            });
        }
        /// Preload cell as module in the virtual pyodide filesystem
        static preload(cell) {
            return new Promise((callback) => {
                PythonRuntime.instance?.queue.push(new CompileRequest(cell, "preload", callback));
            });
        }
        /// Preload cells as modules in the virutal pyodide filesystem
        static preloadAll(cells) {
            const rt = PythonRuntime.instance;
            return new Promise(async (success) => {
                for (const cell of cells) {
                    rt?.queue.push(new CompileRequest(cell, "preload", (response) => {
                        console.log('preload response for ' + response.name);
                    }));
                }
                success(true);
            });
        }
        /// Get warning callbacks
        static addWarningListener(uuid, listener) {
            PythonRuntime.instance?.listeners.set(uuid, listener);
        }
        static removeWarningListener(uuid) {
            PythonRuntime.instance?.listeners.delete(uuid);
        }
        /// Send offscreen canvas to webworker
        /*
        public static setCanvas(uuid : string, canvas : HTMLCanvasElement) {
          if (canvas != null) {
            const offscreen = canvas.transferControlToOffscreen();
            const python = PythonRuntime.getInstance();
            python.worker.postMessage({
              uuid, name: "", code: "", action: "canvas", canvas: offscreen
            }, [offscreen]);
          }
        }
        */
        /// Play button pressed
        static playCell(cell) {
            PythonRuntime.instance?.worker.postMessage({ ...cell, action: "play" });
        }
        /// Pause button pressed
        static pauseCell(cell) {
            PythonRuntime.instance?.worker.postMessage({ ...cell, action: "pause" });
        }
        /// delete a cell
        static deleteCell(cell) {
            const rt = PythonRuntime.instance;
            if (rt) {
                rt.modules.delete(cell.uuid);
                rt.cache.delete(cell.uuid);
                rt.worker.postMessage({ ...cell, action: "delete" });
                // cell deleted dependency warnings
                for (const [key, resp] of rt.cache) {
                    if (key !== cell.uuid) {
                        if (resp.dependencies.includes(cell.name)) {
                            rt.warnings.push({
                                name: "Dependency Warning",
                                message: `Cell '${cell.name}' was deleted.`,
                                details: "", line: -1,
                                target: key,
                                source: cell.uuid
                            });
                        }
                    }
                }
            }
        }
        static getWarnings() {
            return PythonRuntime.instance.warnings;
        }
        hasWarnings(uuid) {
            return this.warnings.find(warn => warn.target === uuid) !== undefined;
        }
        equivalentCode(a, b) {
            function clip(c) {
                return c
                    .split('\n')
                    .filter((l) => (l !== '' && !l.startsWith('#')))
                    .join('\n');
            }
            return clip(a) === clip(b);
        }
        equivalent(request, response) {
            return (!request.force &&
                request.name === response.name &&
                request.action === response.action &&
                this.equivalentCode(request.code, response.code));
        }
        /// fired by the timer to process any pending compile requests
        async processQueue() {
            if (this.queue.length > 0 && this.active === null) {
                // get the first request in the queue
                let request = this.queue.shift();
                // update our list of python modules
                this.modules.set(request.uuid, request.cell);
                // pre-cached?
                let response = this.cache.get(request.uuid);
                if (response && response.code && !this.hasWarnings(request.uuid) && this.equivalent(request, response)) {
                    request.callback(response);
                }
                // no cached result, so call the webworker
                else {
                    // indicate that we're currently compiling to prevent simultaneous calls
                    this.active = request;
                    // clear the keyboard interrupt buffer
                    this.interruptBuffer[0] = 0;
                    // set initiated time so that we can catch infinite loops
                    this.active.initiatedTime = Date.now();
                    // delete any previously saved results
                    this.removeFromCache(request.uuid);
                    // ask the worker to compile our source code
                    this.worker.postMessage({
                        uuid: request.uuid,
                        name: request.name,
                        action: request.action,
                        code: request.code
                    });
                }
            }
            // monitor active compiles in case of infinite loops
            else if (this.active && this.active.initiatedTime > 0 && this.active.action === 'compile') {
                const elapsed = Date.now() - this.active.initiatedTime;
                // pull the plug after 10 seconds
                if (elapsed > 10000 && elapsed < 11000) {
                    /*
                     * fire interrupt using shared array buffer with webworker
                     * to simulate a keyboard interrupt
                     * https://pyodide.org/en/stable/usage/keyboard-interrupts.html
                     */
                    //console.log('Compiling', this.active.uuid, this.active.action, elapsed);
                    this.interruptBuffer[0] = 2; // 2 stands for SIGINT.
                }
            }
            setTimeout(() => { PythonRuntime.instance?.processQueue(); }, 50);
        }
        removeFromCache(uuid) {
            this.cache.get(uuid)?.close();
            this.cache.delete(uuid);
        }
        /// convert a string into a python identifier
        /// append a numerical suffix as many times as needed until unique
        static makePythonSafe(name, uuid) {
            let result = '';
            for (const char of name) {
                let c = char.charCodeAt(0);
                if ((c >= 48 && c <= 57) || // 0-9
                    (c >= 97 && c <= 199) || // a-z
                    (c >= 65 && c <= 90) || // A-Z
                    (c === 95)) // '_'
                 {
                    result += char;
                }
                else if (c === 32) { // SPACE
                    result += '_';
                }
            }
            if (result === '') {
                result = 'new_cell';
            }
            // python identifiers can't start with a number
            if (result.charCodeAt(0) >= 48 && result.charCodeAt(0) <= 57) {
                result = '_' + result;
            }
            // can't be a python keyword
            if (_python_keywords.includes(result)) {
                result = '_' + result;
            }
            // make sure name is unique
            let original = result;
            let counter = 2;
            while (PythonRuntime.instance?.duplicateName(result, uuid)) {
                result = original + "_" + counter;
                counter++;
            }
            return result;
        }
        duplicateName(name, uuid) {
            for (const [key, cell] of this.modules) {
                if (uuid !== key && cell.name === name)
                    return true;
            }
            return false;
        }
    }
    /// singleton pattern
    PythonRuntime.instance = null;
    /**
     * Interface for requesting compiles
     */
    class CompileRequest {
        constructor(cell, action, callback, force = false) {
            /// force a recompile even if code hasn't changed?
            this.force = false;
            /// when was this request first sent to Pyodide to run?
            this.initiatedTime = -1;
            this.cell = cell;
            this.action = action;
            this.callback = callback;
            this.force = force;
        }
        /// resource id for this request (e.g. gadget id)
        get uuid() { return this.cell.uuid; }
        /// name of the tunepad cell
        get name() { return this.cell.name; }
        /// python source code
        get code() { return this.cell.code; }
    }
    class CompileResponse {
        constructor(request) {
            /// list of python standard out (from print statements)
            this.output = [];
            /// trace object generated by the tunepad python api
            this.trace = new MusicTrace();
            /// list of python errors resulting from compile
            this.errors = [];
            /// a list of other cell names that this cell imports
            this.dependencies = [];
            this.uuid = request.uuid;
            this.code = request.code;
            this.name = request.name;
            this.action = request.action;
        }
        get hasErrors() {
            return this.errors.length > 0;
        }
        get hasNoErrors() {
            return this.errors.length === 0;
        }
        /// cleanup any resources associated with this response
        close() { }
    }
    // list of python reserved words to make sure cells have valid python identifier names
    const _python_keywords = [
        'and',
        'as',
        'assert',
        'break',
        'class',
        'continue',
        'def',
        'del',
        'elif',
        'else',
        'except',
        'exec',
        'False',
        'finally',
        'for',
        'from',
        'global',
        'if',
        'import',
        'in',
        'is',
        'lambda',
        'None',
        'nonlocal',
        'not',
        'or',
        'pass',
        'raise',
        'return',
        'True',
        'try',
        'while',
        'with',
        'yield'
    ];

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    /**
     * Readonly / playable /copyable view of TunePad python code
     *
     * <tunepad-code
     *    id = "{{ page-unique id name }}"      // must be a valid python module name
     *    patch = "{{ patch url synth path }}"  // required for audio playback
     *    tempo = "{{ bpm }}"                   // default is 90
     *    time = "{{ time signature }}"         // default is "4/4"
     *    gain = "{{ dB }}"                     // gain for the cell in decibels (0 is default)
     *    midi-out = "true" | "false"           // default is false
     *    midi-voice = {{ number }}>            // if midi-out is true, optionally set midi program
     * # python code inside
     * </tunepad-code>
     *
     * EXAMPLE:
     *
     * <tunepad-code patch="/sounds/voices/grand-piano/" tempo="{{ bpm }}" id="{{ page-unique-id }}">
     * for i in range(8):
     *     playNote(62, beats = 0.5)
     * rest(1)
     * </tunepad-code>
     *
     * HACK FIX FOR MARKDOWN:
     * If you're formatting code in a markdown file and you have blank lines in your code, insert
     * a single forward slash in place of a blank line:
     *
     * <tunepad-code>
     * C = 60
     * /
     * playNote(C)
     * </tunepad-code>
     * This will get stripped out.
     *
     * If the snippet of python code shouldn't generate audio, just omit the patch attribute.
     * Then only the copy button will appear.
     *
     * <tunepad-code id="{{ page-unique-id }}">
     * def my_helper_func():
     *     playNote(60)
     *     playNote(62)
     * </tunepad-code>
     */
    class TunePadCodeView extends HTMLElement {
        get currentBeat() { return this.audio.beats % this.duration; }
        get remainingBeats() { return this.duration - this.currentBeat; }
        get percentBeats() { return (this.currentBeat / this.duration); }
        constructor() {
            super();
            // GUID send to the python compiler
            this.uuid = self.crypto.randomUUID();
            // python "file" name corresponds to the id attribute
            this.name = '';
            // patch attribute
            this.patch = '/sounds/voices/piano/';
            // the python code (inner text of element)
            this.code = '';
            // create a synthesizer
            this.synth = new Synthesizer();
            // controls audio output level (decibels)
            this.gain = 0.0; // dB
            // send midi output?
            this.midiOut = false;
            // midi "program" instrument voice
            this.midiVoice = -1;
            // audio finished loading?
            this.audio_ready = false;
            // should this code play audio?
            this.audible = false;
            // duration of the audio loop in beats (rounded up to nearest measure)
            this.duration = 4;
            this._last_beat = 0;
            this._looped = -1;
            this.root = this.attachShadow({ mode: 'open' });
            this.root.adoptedStyleSheets.push(stylesheet$8);
            this.root.adoptedStyleSheets.push(stylesheet$9);
            const template = document.createElement('template');
            template.innerHTML = html$6;
            this.root.appendChild(template.content.cloneNode(true));
            this.audio = TunePadAudio.init();
        }
        connectedCallback() {
            window.addEventListener('load', () => {
                this.code = this.innerHTML
                    .trim()
                    .split('\n')
                    .map((line) => line.startsWith('/') ? line.substring(1) : line) // ugly markdown hack
                    .join('\n');
                const view = this.root.querySelector('#code-view');
                const el = this.root.querySelector('.code-view-wrapper');
                if (view && el) {
                    view.innerHTML = this.code;
                    Prism.highlightAllUnder(el);
                }
                // if this snippet generates audio, compile the python now
                if (this.audible) {
                    this.compileCode(this.code, true);
                }
            });
            // hook up our button event handlers
            this.root.querySelector('#play-button')?.addEventListener('click', e => this.playAudio());
            this.root.querySelector('#pause-button')?.addEventListener('click', e => this.pauseAudio());
            this.root.querySelector('#stop-button')?.addEventListener('click', (e) => this.audio.stopAll());
            this.root.querySelector('#copy-button')?.addEventListener('click', (e) => {
                navigator.clipboard.writeText(this.code);
            });
        }
        disconnectedCallback() { }
        attributeChangedCallback(name, oldValue, newValue) {
            // if the patch attribute is provided, we can generate audio output
            if (name === 'patch' && newValue !== null) {
                this.audible = true;
                this.patch = newValue;
                this.loadPatch(newValue);
            }
            else if (name === 'id') {
                this.name = PythonRuntime.makePythonSafe(newValue, this.uuid);
                this.status();
                this.setHTML('#status', `${this.name} (python)`);
            }
            else if (name === 'theme') {
                this.removeClass('.code-view-wrapper', oldValue);
                this.addClass('.code-view-wrapper', newValue);
            }
            else if (name === 'tempo') {
                this.audio.bpm = toInt(newValue, 90);
                this.synth.bpm = toInt(newValue, 90);
                this.setHTML('#tempo', `${this.synth.bpm} bpm`);
            }
            else if (name === 'time' && newValue !== null) {
                this.audio.meter = newValue;
                this.setHTML('#time', `${this.audio.meter} time`);
            }
            else if (name == 'gain') {
                this.gain = toNum(newValue, 0.0);
            }
            else if (name === 'midi-out') {
                this.midiOut = newValue === 'true';
                if (this.midiOut)
                    MIDIManager.init();
            }
            else if (name === 'midi-voice') {
                this.midiVoice = parseInt(newValue);
            }
        }
        cueAudio(delta) {
            if (this.trace) {
                if (!this.gain_node) {
                    this.gain_node = new GainNode(this.audio.context);
                    this.gain_node.gain.value = dBToGain(this.gain);
                    this.gain_node.gain.setValueAtTime(this.gain, 0);
                    this.gain_node.connect(this.audio.context.destination);
                }
                this.synth.scheduleNotes(this.trace, this.gain_node, delta);
            }
            if (this.trace && this.midiOut) {
                MIDIManager.outputs?.forEach(port => {
                    this.synth.setMidiProgram(port, this.midiVoice);
                    this.synth.scheduleMidiNotes(this.trace, delta, port, this.gain);
                });
            }
        }
        playAudio() {
            if (this.trace) {
                this.audio.play(this);
                if (this.currentBeat === 0) {
                    this.cueAudio(0);
                }
                else {
                    this.cueAudio(-1 * this.currentBeat);
                }
                if (this.remainingBeats <= 0.5) {
                    this.cueAudio(this.remainingBeats);
                    this._looped = this.currentBeat;
                    this._last_beat = this.currentBeat;
                }
                this.root.querySelector('#play-button')?.classList.add('hidden');
                this.root.querySelector('#pause-button')?.classList.remove('hidden');
                this.animation();
            }
        }
        pauseAudio() {
            this.synth.cancelAllNotes();
            this.audio.pause(this);
            if (this.midiOut) {
                MIDIManager.outputs?.forEach(port => {
                    this.synth.cancelAllMidiNotes(port);
                });
            }
            this.root.querySelector('#play-button')?.classList.remove('hidden');
            this.root.querySelector('#pause-button')?.classList.add('hidden');
        }
        stopAudio() {
            this.pauseAudio();
            this.setFill(0);
            this._looped = -1;
            this._last_beat = 0;
        }
        async compileCode(code, preload = false) {
            PythonRuntime.init();
            this.status();
            if (preload) {
                await PythonRuntime.preload(this);
            }
            const resp = await PythonRuntime.compile(this);
            this.trace = resp.trace;
            this.duration = Math.ceil(resp.trace.beats / this.audio.beatsPerMeasure) * this.audio.beatsPerMeasure;
            this.setHTML('#beats', `${this.duration} beats`);
            if (resp.hasErrors) {
                this.error = resp.errors[0];
            }
            this.status();
        }
        async loadPatch(patch) {
            this.root.querySelector('#loader')?.classList.remove('hidden');
            this.status();
            await this.synth.loadPatch(patch);
            this.setHTML('#patch', this.synth.patch.name);
            this.audio_ready = true;
            this.status();
        }
        animation() {
            if (this.audio.isPlaying(this)) {
                this.setFill(this.percentBeats);
                // less than an 8th note from the end of the current segment or loop?
                if (this.remainingBeats < 0.5 && this._looped < 0) {
                    this._looped = this.currentBeat;
                    this.cueAudio(this.remainingBeats);
                }
                else if (this._looped > this.currentBeat) {
                    this._looped = -1;
                }
                // somehow we missed cueign the audio at the end of the last loop
                else if (this._looped < 0 && this._last_beat > this.currentBeat) {
                    this.cueAudio(-1 * this.currentBeat);
                }
                this._last_beat = this.currentBeat;
                requestAnimationFrame((t) => { this.animation(); });
            }
        }
        setFill(perc) {
            const fill = this.root.querySelector('.progress-bar .fill');
            if (fill) {
                fill.style.width = `${100 * perc}%`;
            }
        }
        status() {
            const e = this.root.querySelector('#status');
            if (!e)
                return;
            if (this.error) {
                this.addClass('footer', 'error');
                this.setHTML('#error', `${this.error.name} (line ${this.error.line})`);
                this.addClass('#loader', 'hidden');
            }
            else if (this.audible) {
                this.removeClass('footer', 'error');
                this.setHTML('#error', '');
                if (this.audio_ready && this.trace) {
                    e.innerHTML = `${this.name} (python)`;
                    this.root.querySelector('#play-button')?.classList.remove('hidden');
                    this.root.querySelector('#stop-button')?.classList.remove('hidden');
                    this.root.querySelector('.progress-bar')?.classList.remove('hidden');
                    this.root.querySelector('#loader')?.classList.add('hidden');
                }
                else if (this.audio_ready) {
                    e.innerHTML = 'Loading python...';
                }
                else if (this.trace) {
                    e.innerHTML = 'Loading audio...';
                }
                else {
                    e.innerHTML = 'Loading...';
                }
            }
        }
        setHTML(selector, html) {
            const e = this.root.querySelector(selector);
            if (e)
                e.innerHTML = html;
        }
        addClass(selector, className) {
            const e = this.root.querySelector(selector);
            if (e)
                e.classList.add(className);
        }
        removeClass(selector, className) {
            const e = this.root.querySelector(selector);
            if (e)
                e.classList.remove(className);
        }
        onClockReset() { this.stopAudio(); }
        onClockTimeChange() { }
        onTempoChange() { }
        onTimeSignatureChange() { }
    }
    TunePadCodeView.ELEMENT = "tunepad-code";
    TunePadCodeView.observedAttributes = [
        "id", // page-unique id for this code snippet (must be valid python identifer) 
        "patch", // url for synth patch json config
        "tempo", // integer bpm value (default "90")
        "time", // time signature <int>/<int> (default "4/4")
        "gain", // gain for the audio output (decibels with default of 0dB)
        "midi-out", // generate midi output (note on | off events)
        "midi-voice" // midi program # http://midi.teragonaudio.com/tech/midispec/pgm.htm
    ];

    const stylesheet$7 = new CSSStyleSheet();
    stylesheet$7.replaceSync(`.explore-wrapper {
    width: 95%;
    margin: 2rem auto;
    padding: 1rem 0;
    border-radius: 20px;
    display: flex;
    flex-direction: column;
}
#code-hint {
    margin: 0rem 0.25rem 0 0;
    padding: 0 1rem;
    background: #0002;
    height: 35px;
    line-height: 35px;
    border: 1px solid #887;
    border-radius: 5px;
    user-select: none;
    box-sizing: border-box;
    flex: 1;
}
.shelf {
    display: flex;
    margin: 1rem 4.5rem;
}
.keyboard-wrapper {
    display: flex;
}
#copy-button {
    color: #000a;
    outline: none;
    border: 1px solid #555;
    height: 35px;
    background-color: transparent;
    border-radius: 5px;
    font-weight: 500;
    user-select: none;
}
#copy-button:hover { color: black; }
#copy-button:active { color: rgb(45, 113, 134); }
piano-instrument { flex: 1; }
`);

    var html$5 = "<div class=\"explore-wrapper\">\n    <div class=\"keyboard-wrapper\">\n        <piano-instrument></piano-instrument> \n    </div>\n    <div class=\"shelf\">\n        <pre id=\"code-hint\"></pre>\n        <button id=\"copy-button\" title=\"Copy Code\">Copy to Clipboard</button>\n    </div>\n</div>";

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    /**
     * Note explorer shows a playable piano keyboard with note names and numbers.
     * Generates playNote statements for notes and chords that you can copy.
     *
     * <note-explorer patch="grand-piano/patch.json"></note-explorer>
     */
    class NoteExplorer extends HTMLElement {
        constructor() {
            super();
            this.notes = new Set();
            this.chord = new Array();
            this.root = this.attachShadow({ mode: 'open' });
            this.root.adoptedStyleSheets.push(stylesheet$7);
            const template = document.createElement('template');
            template.innerHTML = html$5;
            this.root.appendChild(template.content.cloneNode(true));
        }
        connectedCallback() {
            const piano = this.root.querySelector('piano-instrument');
            // catch piano note events and play note + display note info
            piano?.addEventListener('note-on', (e) => {
                const note = new Note(e.detail.note);
                this.addCodeHint(note);
            });
            piano?.addEventListener('note-off', (e) => {
                const note = new Note(e.detail.note);
                this.removeCodeHint(note);
            });
            piano?.addEventListener('click', (e) => {
                const el = document.querySelector('#code-hint');
                if (el)
                    navigator.clipboard.writeText(el.innerHTML);
            });
        }
        disconnectedCallback() {
            //console.log("Custom element removed from page.");
        }
        attributeChangedCallback(name, oldValue, newValue) {
            if (newValue !== oldValue) {
                this.root.querySelector('piano-instrument')?.setAttribute(name, newValue);
            }
        }
        getCodeHint() {
            if (this.chord.length === 1) {
                const note = new Note(this.chord[0]);
                return `playNote(${note.note})    # ${note.nameWithOctave}`;
            }
            else if (this.chord.length > 0) {
                return `playNote([ ${this.chord.join(', ')} ])`;
            }
            else {
                return '';
            }
        }
        addCodeHint(note) {
            this.notes.add(note.note);
            this.chord = [...this.notes].sort();
            const el = this.root.getElementById('code-hint');
            if (el)
                el.innerHTML = this.getCodeHint();
        }
        removeCodeHint(note) {
            this.notes.delete(note.note);
            if (this.notes.size == 0)
                this.chord = [];
        }
    }
    NoteExplorer.ELEMENT = "note-explorer";
    NoteExplorer.observedAttributes = Piano.observedAttributes;

    const stylesheet$6 = new CSSStyleSheet();
    stylesheet$6.replaceSync(`/*
 * TunePad
 * Northwestern University
 * michael-horn@northwestern.edu
 *
 * This project was funded by the National Science Foundation (grant DRL-1612619).
 * Any opinions, findings and conclusions or recommendations expressed in this
 * material are those of the author(s) and do not necessarily reflect the views
 * of the National Science Foundation (NSF).
 */
 :host {
    --error-red: #da575d;
    --error-red-bg: #f9e4e5;
    --fail-red: #da575d;
    --fail-red-bg: #f9e4e5;
    --info-blue: #4b90d7;
    --pass-green: green;
    --pass-green-bg: #ded;
    --warn-yellow: orange;
    --warn-yellow-bg: #fed;
    --output-badge-color: #87c44e;
    --error-badge-color: #da575d;
    --warn-badge-color: orange;
 }
.python-message {
    padding: 10px;
    font-size: 12px;
    position: relative;
    margin: 0.25em 0;
}

.python-message.error {
    background-color: white;
    border-left: 10px solid var(--error-red);
}

.python-message.message {
    background-color: white;
    border-left: 10px solid var(--info-blue);
}

.python-message.warning {
    background-color: white;
    border-left: 10px solid var(--warn-yellow);
}

.python-message.test {
    background-color: var(--fail-red-bg);
    border-left: 10px solid var(--fail-red);
}

.python-message.test.pass {
    background-color: var(--pass-green-bg);
    border-left: 10px solid var(--pass-green);
}

.icon {
    width: 20px;
    margin-right: 0.75em;
    position: relative;
    top: 2px;
}
.error .icon { fill: var(--error-red); }
.warning .icon { fill: var(--warn-yellow); }
.test .icon { fill: var(--fail-red); }
.test.pass .icon { fill: var(--pass-green); }
.message .icon { fill: var(--info-blue); }

.message-box {
    color: #444;
    position: relative;
    display: flex;
    flex-wrap: wrap;
}
#message { 
    flex: 1; 
    align-content: center;
    font-size: 14px;
}

#status {
    font-size: 70%;
    border-radius: 8px;
    background-color: var(--fail-red);
    padding: 0 1.5em;
    font-weight: bold;
    color: white;
    width: 40px;
    height: 16px;
    line-height: 16px;
    text-align: center;
    align-self: center;
    display: none;
}
.test #status { display: block;}
.test.pass #status { background-color: var(--pass-green); }

.details-box {
    display: flex;
}
.details-box.hidden {
    display: none;
}
#details {
    line-height: 150%;
    font-size: 11px;
    margin-left: 2.5em;
    margin-right: 1em;
    background-color: var(--error-red-bg);
    padding: 1em;
    overflow-x: auto;
    flex: 1;
}

.view-btn {
    outline: none;
    border: none;
    background-color: transparent;
    border-radius: 0.5em;
    width: 3em;
    height: 2em;
    padding: 0 0.9rem;
    display: none;
}
.error .view-btn { display: block; }
.error .view-btn.hidden { display: none; }
.view-btn:hover { background-color: #0001; }


.infoLinks {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 65px;
    margin-left: 1rem;
}

.infoLinks a {
    width: 22px;
    filter: grayscale(100%);
    text-decoration: none;
}
.infoLinks a.ggl-search { width: 20px; }
.infoLinks a:hover { filter: none; }
`);

    var html$4 = "<div class=\"python-message\">\n    <div class=\"message-box\">\n        <div class=\"icon\"></div>\n\n        <div id=\"message\"></div>\n\n        <div id=\"status\">PASSED</div>\n\n        <button id=\"collapse-button\" class=\"view-btn hidden\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 448 512\">\n                <path d=\"M201.4 137.4c12.5-12.5 32.8-12.5 45.3 0l160 160c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L224 205.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l160-160z\"/>\n            </svg>\n        </button>\n        <button id=\"expand-button\" class=\"view-btn\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 448 512\">\n                <path d=\"M201.4 374.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 306.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z\"/>\n            </svg>\n        </button>\n    </div>\n    <div class=\"details-box hidden\">\n        <pre id=\"details\">No stack trace available.</pre>\n        <div class=\"infoLinks\">\n            <a class=\"ggl-search\" target=\"_blank\" rel=\"noreferrer\" title=\"Search for error on Google\"></a>\n            <a class=\"ddg-search\" target=\"_blank\" rel=\"noreferrer\" title=\"Search for error on DuckDuckGo\"></a>\n            <!--\n             <a className={ styles.ddg }\n              target=\"_blank\"\n              rel=\"noreferrer\"\n              href={ \"//duckduckgo.com?q=\" + error?.name + \" \" + error?.message } \n              data-tooltip=\"search for error message on DuckDuckGo\">\n            &nbsp;\n            </a>\n            -->\n        </div>\n    </div>\n</div>";

    var errorIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n    <circle cx=\"256\" cy=\"256\" r=\"250\" fill=\"white\"/>\n    <path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm0-384c13.3 0 24 10.7 24 24V264c0 13.3-10.7 24-24 24s-24-10.7-24-24V152c0-13.3 10.7-24 24-24zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z\"/>\n</svg>";

    var infoIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n    <!--!Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->\n    <path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336h24V272H216c-13.3 0-24-10.7-24-24s10.7-24 24-24h48c13.3 0 24 10.7 24 24v88h8c13.3 0 24 10.7 24 24s-10.7 24-24 24H216c-13.3 0-24-10.7-24-24s10.7-24 24-24zm40-208a32 32 0 1 1 0 64 32 32 0 1 1 0-64z\"/>\n</svg>";

    var warnIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 512 512\">\n  <path fill=\"white\" d=\"M258,108c10.5,0,20.3,5.6,25.6,14.7l160.3,273.1c5.4,9.2,5.4,20.6.1,29.8s-15.1,14.9-25.8,14.9H97.7c-10.6,0-20.5-5.7-25.8-14.9s-5.2-20.6.1-29.8L232.4,122.7c5.3-9.1,15.1-14.7,25.6-14.7Z\"/>\n  <path d=\"M256,32c14.2,0,27.3,7.5,34.5,19.8l216,368c7.3,12.4,7.3,27.7.2,40.1s-20.4,20.1-34.7,20.1H40c-14.3,0-27.6-7.7-34.7-20.1s-7-27.8.2-40.1L221.5,51.8c7.2-12.3,20.3-19.8,34.5-19.8ZM256,160c-13.3,0-24,10.7-24,24v112c0,13.3,10.7,24,24,24s24-10.7,24-24v-112c0-13.3-10.7-24-24-24ZM288,384c0-17.7-14.3-32-32-32s-32,14.3-32,32,14.3,32,32,32,32-14.3,32-32Z\"/>\n</svg>";

    var crossIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n    <!--!Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->\n    <path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM175 175c9.4-9.4 24.6-9.4 33.9 0l47 47 47-47c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6 0-33.9z\"/>\n</svg>";

    var checkIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n    <!--!Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->\n    <path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM369 209L241 337c-9.4 9.4-24.6 9.4-33.9 0l-64-64c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l47 47L335 175c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9z\"/>\n</svg>";

    var googleLogo = "<svg viewBox=\"0 0 533.5 544.3\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M533.5 278.4c0-18.5-1.5-37.1-4.7-55.3H272.1v104.8h147c-6.1 33.8-25.7 63.7-54.4 82.7v68h87.7c51.5-47.4 81.1-117.4 81.1-200.2z\" fill=\"#4285f4\"/><path d=\"M272.1 544.3c73.4 0 135.3-24.1 180.4-65.7l-87.7-68c-24.4 16.6-55.9 26-92.6 26-71 0-131.2-47.9-152.8-112.3H28.9v70.1c46.2 91.9 140.3 149.9 243.2 149.9z\" fill=\"#34a853\"/><path d=\"M119.3 324.3c-11.4-33.8-11.4-70.4 0-104.2V150H28.9c-38.6 76.9-38.6 167.5 0 244.4l90.4-70.1z\" fill=\"#fbbc04\"/><path d=\"M272.1 107.7c38.8-.6 76.3 14 104.4 40.8l77.7-77.7C405 24.6 339.7-.8 272.1 0 169.2 0 75.1 58 28.9 150l90.4 70.1c21.5-64.5 81.8-112.4 152.8-112.4z\" fill=\"#ea4335\"/></svg>";

    var ddgLogo = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg viewBox=\"0 0 256 255\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" preserveAspectRatio=\"xMidYMid\">\n    <defs>\n        <linearGradient x1=\"71.0046292%\" y1=\"100%\" x2=\"0%\" y2=\"100%\" id=\"linearGradient-1\">\n            <stop stop-color=\"#394A9F\" offset=\"0%\"></stop>\n            <stop stop-color=\"#6176B9\" offset=\"100%\"></stop>\n        </linearGradient>\n    </defs>\n\t<g>\n\t\t<path d=\"M128.145,18.841 C188.147,18.841 236.788,67.482 236.788,127.484 C236.788,187.485 188.147,236.126 128.145,236.126 C68.144,236.126 19.503,187.485 19.503,127.484 C19.503,67.482 68.144,18.841 128.145,18.841\" fill=\"#DE5833\"></path>\n\t\t<path d=\"M128.143,254.922 C198.526,254.922 255.583,197.865 255.583,127.482 C255.583,57.099 198.526,0.042 128.143,0.042 C57.76,0.042 0.703,57.099 0.703,127.482 C0.703,197.865 57.76,254.922 128.143,254.922 L128.143,254.922 Z M128.143,244.302 C63.625,244.302 11.323,192 11.323,127.482 C11.323,62.964 63.625,10.662 128.143,10.662 C192.661,10.662 244.963,62.964 244.963,127.482 C244.963,192 192.661,244.302 128.143,244.302 L128.143,244.302 Z\" fill=\"#DE5833\"></path>\n\t\t<g transform=\"translate(66.000000, 42.000000)\">\n\t\t\t<path d=\"M9.219,12.13 C9.198,10.303 10.525,9.28 12.288,8.563 C11.481,8.695 10.708,8.897 10.012,9.209 C8.174,10.042 6.8,13.196 6.813,14.689 C15.736,13.787 28.931,14.411 38.58,17.291 C39.292,17.191 40.004,17.091 40.727,17.008 C31.103,12.735 19.661,11.085 9.219,12.13\" fill=\"#D5D7D8\"></path>\n\t\t\t<path d=\"M11.048,1.15 C11.249,1.114 11.453,1.089 11.655,1.055 C9.73,1.294 8.715,1.982 7.27,2.219 C8.839,2.358 14.784,5.133 18.52,6.659 C19.044,6.46 19.516,6.239 19.901,5.978 C17.964,5.692 13.151,1.342 11.048,1.15\" fill=\"#D5D7D8\"></path>\n\t\t\t<path d=\"M20.326,22.756 C19.791,22.962 19.283,23.177 18.843,23.408 C4.298,31.071 -2.127,48.97 1.702,70.418 C5.197,89.936 19.522,156.623 26.081,187.989 C27.996,188.662 29.934,189.287 31.896,189.854 C26.055,161.614 10.112,87.614 6.392,66.831 C2.621,45.688 6.29,30.517 20.326,22.756\" fill=\"#D5D7D8\"></path>\n\t\t\t<path d=\"M79.184,176.618 C78.944,176.778 78.658,176.928 78.353,177.074 C78.127,177.95 77.782,178.614 77.279,178.948 C74.275,180.941 65.79,181.945 61.31,180.941 C60.539,180.77 59.955,180.487 59.499,180.098 C51.85,184.345 40.85,189.999 38.616,188.725 C35.126,186.724 34.62,160.274 35.126,153.783 C35.495,148.883 52.707,156.82 61.08,160.983 C62.931,159.254 67.466,158.097 71.48,157.704 C65.415,142.943 60.942,126.059 63.684,114.086 C59.894,111.445 54.871,105.32 55.917,98.927 C56.723,94.061 69.297,84.855 78.2,84.299 C87.123,83.736 89.904,83.863 97.338,82.083 C97.71,81.994 98.119,81.896 98.547,81.793 C103.123,65.706 92.148,37.719 79.906,25.472 C75.915,21.481 69.779,18.969 62.865,17.643 C60.206,13.994 55.917,10.505 49.845,7.274 C38.57,1.288 24.636,-1.149 11.655,1.055 C11.453,1.089 11.249,1.114 11.048,1.15 C13.151,1.342 17.964,5.692 19.901,5.978 C19.516,6.239 19.044,6.46 18.52,6.659 C16.702,7.351 14.231,7.771 12.288,8.563 C10.525,9.28 9.198,10.303 9.219,12.13 C19.661,11.085 31.103,12.735 40.727,17.008 C40.004,17.091 39.292,17.191 38.58,17.291 C31.755,18.251 25.482,20.019 20.95,22.41 C20.737,22.521 20.535,22.641 20.326,22.756 C6.29,30.517 2.621,45.688 6.392,66.831 C10.112,87.614 26.1589994,162.759995 31.9999994,190.999995 C41.6029994,193.778995 50.5819993,195.999995 61.0799993,195.999995 C69.9919993,195.999995 80.7110013,194.024995 89.0000013,191.999995 C86.0890013,186.386995 82.344,180.18 80.036,175.729 C79.728,176.096 79.485,176.417 79.184,176.618 Z M85.057,70.057 C81.253,70.057 78.15,66.963 78.15,63.137 C78.15,59.329 81.253,56.234 85.057,56.234 C88.882,56.234 91.973,59.329 91.973,63.137 C91.973,66.963 88.882,70.057 85.057,70.057 L85.057,70.057 Z M89.218,44.049 C89.218,44.049 84.861,41.56 81.48,41.602 C74.532,41.693 72.64,44.763 72.64,44.763 C72.64,44.763 73.806,37.445 82.691,38.913 C87.508,39.714 89.218,44.049 89.218,44.049 L89.218,44.049 Z M15.963,53.046 C15.963,53.046 12.834,46.073 21.173,42.656 C29.521,39.238 33.586,44.601 33.586,44.601 C33.586,44.601 27.524,41.859 21.63,45.563 C15.746,49.263 15.963,53.046 15.963,53.046 L15.963,53.046 Z M23.253,67.908 C23.253,63.462 26.848,59.864 31.3,59.864 C35.74,59.864 39.34,63.462 39.34,67.908 C39.34,72.355 35.74,75.949 31.3,75.949 C26.848,75.951 23.253,72.355 23.253,67.908 L23.253,67.908 Z\" fill=\"#FFFFFF\"></path>\n\t\t\t<path d=\"M39.34,67.908 C39.34,63.462 35.74,59.864 31.3,59.864 C26.848,59.864 23.253,63.462 23.253,67.908 C23.253,72.355 26.848,75.951 31.3,75.949 C35.74,75.949 39.34,72.355 39.34,67.908 L39.34,67.908 Z M34.862,67.317 C33.72,67.32 32.781,66.381 32.781,65.227 C32.781,64.07 33.717,63.139 34.862,63.139 C36.016,63.139 36.952,64.07 36.952,65.227 C36.952,66.381 36.016,67.317 34.862,67.317 L34.862,67.317 Z\" fill=\"#2D4F8E\"></path>\n\t\t\t<path d=\"M34.862,63.139 C33.717,63.139 32.781,64.07 32.781,65.227 C32.781,66.381 33.72,67.32 34.862,67.317 C36.016,67.317 36.952,66.381 36.952,65.227 C36.952,64.07 36.016,63.139 34.862,63.139\" fill=\"#FFFFFF\"></path>\n\t\t\t<path d=\"M85.057,56.234 C81.253,56.234 78.15,59.329 78.15,63.137 C78.15,66.963 81.253,70.057 85.057,70.057 C88.882,70.057 91.973,66.963 91.973,63.137 C91.973,59.329 88.882,56.234 85.057,56.234 L85.057,56.234 Z M88.124,62.628 C87.149,62.628 86.344,61.835 86.344,60.839 C86.344,59.856 87.149,59.049 88.124,59.049 C89.141,59.049 89.921,59.856 89.921,60.839 C89.921,61.835 89.141,62.628 88.124,62.628 L88.124,62.628 Z\" fill=\"#2D4F8E\"></path>\n\t\t\t<path d=\"M88.124,59.049 C87.149,59.049 86.344,59.856 86.344,60.839 C86.344,61.835 87.149,62.628 88.124,62.628 C89.141,62.628 89.921,61.835 89.921,60.839 C89.921,59.856 89.141,59.049 88.124,59.049\" fill=\"#FFFFFF\"></path>\n\t\t\t<path d=\"M33.586,44.601 C33.586,44.601 29.521,39.238 21.173,42.656 C12.834,46.073 15.963,53.046 15.963,53.046 C15.963,53.046 15.746,49.263 21.63,45.563 C27.524,41.859 33.586,44.601 33.586,44.601\" fill=\"url(#linearGradient-1)\"></path>\n\t\t\t<path d=\"M82.691,38.913 C73.806,37.445 72.64,44.763 72.64,44.763 C72.64,44.763 74.532,41.693 81.48,41.602 C84.861,41.56 89.218,44.049 89.218,44.049 C89.218,44.049 87.508,39.714 82.691,38.913\" fill=\"url(#linearGradient-1)\"></path>\n\t\t\t<path d=\"M78.2,84.299 C69.297,84.855 56.723,94.061 55.917,98.927 C54.871,105.32 59.894,111.445 63.684,114.086 C63.694,114.093 63.705,114.102 63.715,114.109 C67.504,116.745 92.733,125.256 105.25,125.02 C117.781,124.776 138.361,117.102 136.101,110.953 C133.851,104.802 113.412,116.38 92.094,114.404 C76.306,112.937 73.519,105.864 77.015,100.698 C81.412,94.205 89.421,101.93 102.631,97.977 C115.861,94.035 134.363,86.979 141.228,83.137 C157.101,74.288 134.586,70.618 129.268,73.073 C124.227,75.402 106.681,79.83 98.547,81.793 C98.119,81.896 97.71,81.994 97.338,82.083 C89.904,83.863 87.123,83.736 78.2,84.299\" fill=\"#FDD209\"></path>\n\t\t</g>\n\t\t<g transform=\"translate(100.000000, 189.000000)\">\n\t\t\t<path d=\"M24.316,17.97 C24.316,17.049 25.057,16.234 26.233,15.539 C26.266,14.98 26.57,14.46 27.08,13.983 C18.707,9.82 1.495,1.883 1.126,6.783 C0.62,13.274 1.126,39.724 4.616,41.725 C6.85,42.999 17.85,37.345 25.499,33.098 C23.292,31.217 24.316,26.651 24.316,17.97\" fill=\"#65BC46\"></path>\n\t\t\t<path d=\"M45.925,28.686 C45.961,28.7 46,28.715 46.036,28.729 C52.89,31.374 66.534,36.353 69.497,35.266 C73.492,33.739 72.492,1.813 68.008,0.796 C64.416,-0.001 50.665,9.688 45.255,13.635 C46.212,17.676 47.37,25.68 45.925,28.686\" fill=\"#65BC46\"></path>\n\t\t\t<path d=\"M29.214,31.611 C24.719,30.615 26.221,26.118 26.221,15.64 C26.221,15.606 26.231,15.573 26.233,15.539 C25.057,16.234 24.316,17.049 24.316,17.97 C24.316,26.651 23.292,31.217 25.499,33.098 C25.955,33.487 26.539,33.77 27.31,33.941 C31.79,34.945 40.275,33.941 43.279,31.948 C43.782,31.614 44.127,30.95 44.353,30.074 C40.837,31.758 33.329,32.547 29.214,31.611\" fill=\"#43A244\"></path>\n\t\t\t<path d=\"M27.08,13.983 C26.57,14.46 26.266,14.98 26.233,15.539 C26.231,15.573 26.221,15.606 26.221,15.64 C26.221,26.118 24.719,30.615 29.214,31.611 C33.329,32.547 40.837,31.758 44.353,30.074 C44.658,29.928 44.944,29.778 45.184,29.618 C45.485,29.417 45.728,29.096 45.925,28.686 C47.37,25.68 46.212,17.676 45.255,13.635 C45.044,12.746 44.844,12.046 44.683,11.636 C44.27,10.614 41.089,10.351 37.48,10.704 C33.466,11.097 28.931,12.254 27.08,13.983\" fill=\"#65BC46\"></path>\n\t\t</g>\n\t</g>\n</svg>";

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    /**
     * <python-message type="test" pass="true">{ message }</python-message>
     */
    class PythonMessage extends HTMLElement {
        static DefineElement() {
            customElements.define("python-message", PythonMessage);
        }
        constructor() {
            super();
            this.pass = false;
            this.type = "message";
            this.message = "";
            this.root = this.attachShadow({ mode: 'open' });
            this.root.adoptedStyleSheets.push(stylesheet$6);
            const template = document.createElement('template');
            template.innerHTML = html$4;
            this.root.appendChild(template.content.cloneNode(true));
            this.setHTML('.ggl-search', googleLogo);
            this.setHTML('.ddg-search', ddgLogo);
        }
        connectedCallback() {
            this.message = this.root.host.innerHTML.trim();
            this.setFields();
            this.root.querySelector('#expand-button')?.addEventListener('pointerup', (evt) => {
                this.addClass('#expand-button', 'hidden');
                this.removeClass('#collapse-button', 'hidden');
                this.removeClass('.details-box', 'hidden');
            });
            this.root.querySelector('#collapse-button')?.addEventListener('pointerup', (evt) => {
                this.removeClass('#expand-button', 'hidden');
                this.addClass('#collapse-button', 'hidden');
                this.addClass('.details-box', 'hidden');
            });
        }
        disconnectedCallback() { }
        attributeChangedCallback(name, oldValue, newValue) {
            if (newValue === oldValue)
                return;
            if (name === 'type' && ['message', 'error', 'warning', 'test'].includes(newValue)) {
                this.type = newValue;
            }
            else if (name === 'pass') {
                this.pass = (newValue === 'true');
            }
            else if (name === 'details') {
                this.details = newValue;
            }
            this.setFields();
        }
        setFields() {
            this.addClass('.python-message', this.type);
            this.setHTML('#message', this.message);
            this.setHTML('#details', this.details ? this.details : 'No stack trace available.');
            if (this.pass)
                this.addClass('.python-message', 'pass');
            this.setHTML('#status', this.pass ? 'PASSED' : 'FAILED');
            if (this.type === 'message') {
                this.setHTML('.icon', infoIcon);
            }
            else if (this.type === 'warning') {
                this.setHTML('.icon', warnIcon);
            }
            else if (this.type === 'error') {
                this.setHTML('.icon', errorIcon);
            }
            else if (this.type === 'test' && this.pass) {
                this.setHTML('.icon', checkIcon);
            }
            else if (this.type === 'test') {
                this.setHTML('.icon', crossIcon);
            }
            const q = encodeURI(`q=${this.message.replace(/<[^>]*>?/gm, '')}`);
            this.root.querySelector('.ddg-search')?.setAttribute('href', '//duckduckgo.com?' + q);
            this.root.querySelector('.ggl-search')?.setAttribute('href', '//google.com?' + q);
        }
        setHTML(selector, html) {
            const e = this.root.querySelector(selector);
            if (e)
                e.innerHTML = html;
        }
        addClass(selector, className) {
            const e = this.root.querySelector(selector);
            if (e)
                e.classList.add(className);
        }
        removeClass(selector, className) {
            const e = this.root.querySelector(selector);
            if (e)
                e.classList.remove(className);
        }
    }
    PythonMessage.observedAttributes = [
        'type', // "error" | "message" | "warning" | "test" (default is "message")
        'pass', // "true" | "false" (default is "false")
        'details' // stack trace for error message
    ];

    const stylesheet$5 = new CSSStyleSheet();
    stylesheet$5.replaceSync(`/*
 * TunePad
 * Northwestern University
 * michael-horn@northwestern.edu
 *
 * This project was funded by the National Science Foundation (grant DRL-1612619).
 * Any opinions, findings and conclusions or recommendations expressed in this
 * material are those of the author(s) and do not necessarily reflect the views
 * of the National Science Foundation (NSF).
 */
 :host {
    --output-badge-color: #87c44e;
 }

.python-output {
    background-color: white;
    color: #444;
    font-size: 12px;
    margin: 0.25em 0;
    padding: 10px;
    border-left: 10px solid var(--output-badge-color);
}

.toolbar {
    font-size: 14px;
    display: flex;
    line-height: 2em;
}

.expander {
    flex: 1;
}

.view-btn {
    outline: none;
    border: none;
    background-color: transparent;
    border-radius: 0.5em;
    width: 3em;
    height: 2em;
    padding: 0 0.9rem;
    display: block;
}
.view-btn:hover { background-color: #0001; }
.view-btn.hidden { display: none; }

#output-container {
    max-height: 250px;
    font-family: monospace;
    overflow-y: auto;
    line-height: 140%;
    padding: 1em;
    text-wrap: wrap;
    font-size: 12px;
    background-color: #eee;
    display: block;
    box-shadow: 0 0 3px inset #0003;
}
#output-container.hidden { display: none; }

.counter {
    color: white;
    background-color: var(--output-badge-color);
    font-size: 90%;
    border-radius: 0.65em;
    margin-right: 1em;
    text-align: center;
    height: 20px;
    min-width: 1.5em;
    line-height: 20px;
    padding: 0 0.4em;
    align-self: center;
}`);

    var html$3 = "<div class=\"python-output\">\n    <div class=\"toolbar\">\n        <div class=\"counter\"></div>\n        Python Output\n        <div class=\"expander\"></div>\n        <button id=\"collapse-button\" class=\"view-btn hidden\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 448 512\">\n                <path d=\"M201.4 137.4c12.5-12.5 32.8-12.5 45.3 0l160 160c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L224 205.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l160-160z\"/>\n            </svg>\n        </button>\n        <button id=\"expand-button\" class=\"view-btn\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 448 512\">\n                <path d=\"M201.4 374.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 306.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z\"/>\n            </svg>\n        </button>\n    </div>\n    <pre id=\"output-container\" class=\"hidden\">Output Uo</pre>\n</div>\n";

    /*
     * TunePad
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    /**
     * <python-output>{ output }</python-output>
     */
    class PythonOutput extends HTMLElement {
        static DefineElement() {
            customElements.define("python-output", PythonOutput);
        }
        constructor() {
            super();
            this.root = this.attachShadow({ mode: 'open' });
            this.root.adoptedStyleSheets.push(stylesheet$5);
            const template = document.createElement('template');
            template.innerHTML = html$3;
            this.root.appendChild(template.content.cloneNode(true));
        }
        connectedCallback() {
            const output = this.root.host.innerHTML.trim();
            const count = output.split('\n').length;
            this.setHTML('#output-container', output);
            this.setHTML('.counter', `${count}`);
            this.root.querySelector('.toolbar')?.addEventListener('pointerup', (evt) => {
                this.toggleClass('#expand-button', 'hidden');
                this.toggleClass('#collapse-button', 'hidden');
                this.toggleClass('#output-container', 'hidden');
            });
        }
        disconnectedCallback() { }
        setHTML(selector, html) {
            const e = this.root.querySelector(selector);
            if (e)
                e.innerHTML = html;
        }
        toggleClass(selector, className) {
            const e = this.root.querySelector(selector);
            if (e)
                e.classList.toggle(className);
        }
        addClass(selector, className) {
            const e = this.root.querySelector(selector);
            if (e)
                e.classList.add(className);
        }
        removeClass(selector, className) {
            const e = this.root.querySelector(selector);
            if (e)
                e.classList.remove(className);
        }
    }
    PythonOutput.observedAttributes = [];

    const stylesheet$4 = new CSSStyleSheet();
    stylesheet$4.replaceSync(`.code-view-wrapper {
    overflow: hidden;
    position: relative;
    background-color: #e3e9f2;
}

.code-view-wrapper.light { background-color: #e3e9f2; }
.code-view-wrapper.dark { background-color: #2E303F; }

@media print {
    .buttons { display: none; }
}

@keyframes spin-animation {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(359deg);
    }
}`);

    const stylesheet$3 = new CSSStyleSheet();
    stylesheet$3.replaceSync(`/*
 * TunePad
 * Northwestern University
 * michael-horn@northwestern.edu
 *
 * This project was funded by the National Science Foundation (grant DRL-1612619).
 * Any opinions, findings and conclusions or recommendations expressed in this
 * material are those of the author(s) and do not necessarily reflect the views
 * of the National Science Foundation (NSF).
 */
:host {
    --error-red: #da575d;
    --error-red-bg: #f9e4e5;
    --fail-red: #da575d;
    --fail-red-bg: #f9e4e5;
    --info-blue: #4b90d7;
    --pass-green: green;
    --pass-green-bg: #ded;
    --warn-yellow: orange;
    --warn-yellow-bg: #fed;
    --output-badge-color: #87c44e;
    --error-badge-color: #da575d;
    --warn-badge-color: orange;
    --fail-badge-color: #da575d;
    --pass-badge-color: green;
    --piano-color: #2f9aef;
    --guitar-color: #f0c229;
    --marimba-color: #f6843f;
    --sequencer-color: #f6843f;
    --bass-color: #ec5eb2;
    --drum-color: #86c44e;
    --sound-color: lightseagreen;
    --text-color: #30acac;
    --definitions-color: #996dd9;
    --cell-header-bg-color: #2e303f;
}
`);

    var html$2 = "<div class=\"code-view-wrapper\">\n    <div class=\"codemirror-container\"></div>\n    <div class=\"message-wrapper\">\n        <div id=\"errors\"></div>\n        <div id=\"warnings\"></div>\n        <div id=\"messages\"></div>\n        <div id=\"tests\"></div>\n        <div id=\"output\"></div>\n    </div>\n</div>\n";

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    /**
     * ## TunePad python editor
     * Capable of compiling code and displaying errors, output, messages, warnings.
     * No audio output. Minimal UI.
     *
     * ```html
     * <tunepad-python-editor
     *    uuid = "{{ datastore id }}"    // should stay constant
     *    name = "{{ module name }}"     // python "file" name (required, must be valid python identifer)
     *    readonly = "true" | "false"    // default is false
     *    theme = "dark" | "light">      // default is "light"
     * playNote(30)  # default Python code here...
     * </tunepad-python-editor>
     * ```
     */
    class TunePadPythonEditor extends HTMLElement {
        /** contents of the code editor */
        get code() { return this.editor.code; }
        /** set this to override initial editor content */
        set initialContent(s) { this.editor.initialContent = s; }
        constructor() {
            super();
            /** GUID sent to the python compiler */
            this.uuid = self.crypto.randomUUID();
            /** python "file" name corresponds to the id attribute */
            this.name = 'tunepad-editor';
            this._preloaded = false;
            this.root = this.attachShadow({ mode: 'open' });
            this.root.adoptedStyleSheets.push(stylesheet$3);
            this.root.adoptedStyleSheets.push(stylesheet$4);
            const template = document.createElement('template');
            template.innerHTML = html$2;
            this.root.appendChild(template.content.cloneNode(true));
            this.editor = document.createElement("python-editor");
        }
        async connectedCallback() {
            this.editor.innerHTML = this.innerHTML;
            this.root.querySelector('.codemirror-container')?.appendChild(this.editor);
        }
        disconnectedCallback() { }
        attributeChangedCallback(name, oldValue, newValue) {
            if (name === 'name') {
                this.name = newValue;
            }
            else if (name === 'uuid') {
                this.uuid = newValue;
            }
            else if (name === 'readonly') {
                this.editor.setAttribute('readonly', `${(newValue === 'true')}`);
            }
            else if (name === 'theme') {
                this.editor.setAttribute('theme', newValue);
                this.removeClass('.code-view-wrapper', oldValue);
                this.addClass('.code-view-wrapper', newValue);
            }
        }
        /**
         * A list of errors to show below the editor
         */
        set errors(errs) {
            this.setHTML('#errors', '');
            errs.forEach((err) => {
                let m = `<b>${err.name}:</b> ${err.message}`;
                if (err.line > 0)
                    m += ` on line ${err.line}`;
                const el = document.createElement('python-message');
                el.setAttribute('type', 'error');
                if (err.details)
                    el.setAttribute('details', err.details);
                el.innerHTML = m;
                this.root.querySelector('#errors')?.appendChild(el);
            });
            // error markers in the editor gutter
            const markers = errs
                .filter(err => err.line > 0)
                .map((err) => {
                return { line: err.line, message: `${err.name}: ${err.message}` };
            });
            this.editor.setMarkers(markers, 'error');
        }
        /**
         * A list of warnings to show below the editor
         */
        set warnings(warns) {
            this.setHTML('#warnings', '');
            warns.forEach((warn) => {
                let m = `<b>${warn.name}:</b> ${warn.message}`;
                if (warn.line > 0)
                    m += ` on line ${warn.line}`;
                const el = document.createElement('python-message');
                el.setAttribute('type', 'warning');
                el.innerHTML = m;
                this.root.querySelector('#warnings')?.appendChild(el);
            });
            // warning markers in the editor gutter
            const markers = warns
                .filter(warn => warn.line > 0)
                .map(warn => {
                return { line: warn.line, message: `${warn.name}: ${warn.message}` };
            });
            this.editor.setMarkers(markers, 'warning');
        }
        /**
         * A list of unit test results to show below the editor
         */
        set unitTests(tests) {
            this.setHTML('#tests', '');
            tests.forEach((test) => {
                const el = document.createElement('python-message');
                el.setAttribute('type', 'test');
                el.setAttribute('pass', `${test.params.get('type') === 'pass'}`);
                el.innerHTML = toStr(test.params.get('message'), '');
                this.root.querySelector('#tests')?.appendChild(el);
            });
        }
        /**
         * A list of messages to show below the editor
         */
        set messages(msgs) {
            this.setHTML('#messages', '');
            msgs.forEach((msg) => {
                const el = document.createElement('python-message');
                el.setAttribute('type', 'message');
                el.innerHTML = toStr(msg.params.get('message'), '');
                this.root.querySelector('#messages')?.appendChild(el);
            });
        }
        /**
         * A list of print outputs to show below the editor
         */
        set output(out) {
            this.setHTML('#output', '');
            if (out.length > 0) {
                const el = document.createElement('python-output');
                el.innerHTML = out.join('\n');
                this.root.querySelector('#output')?.appendChild(el);
            }
        }
        /**
         * Initialize collaborative editing
         */
        bindCollaboration(ytext, awareness) {
            this.editor.bindCollaboration(ytext, awareness);
        }
        /**
         * Trigger a python compile and display any errors, warnings, messages, or print outputs
         * that result.
         */
        async recompile() {
            PythonRuntime.init();
            // preload the python module filesystem
            if (!this._preloaded) {
                await PythonRuntime.preload(this);
                this._preloaded = true;
            }
            // compile the python code
            const resp = await PythonRuntime.compile(this);
            // show errors, messages, unit tests, and python print output
            // note that warnings come from an external listener set on PythonRuntime
            this.errors = resp.errors;
            this.output = resp.output;
            this.messages = resp.trace.messages;
            this.unitTests = resp.trace.unitTests;
            return resp;
        }
        setHTML(selector, html) {
            const e = this.root.querySelector(selector);
            if (e)
                e.innerHTML = html;
        }
        addClass(selector, className) {
            const e = this.root.querySelector(selector);
            if (e)
                e.classList.add(className);
        }
        removeClass(selector, className) {
            const e = this.root.querySelector(selector);
            if (e)
                e.classList.remove(className);
        }
    }
    TunePadPythonEditor.ELEMENT = "tunepad-python-editor";
    TunePadPythonEditor.observedAttributes = [
        "uuid", // datastore-unique id for this code snippet
        "name", // python "file" name (required, must be valid python identifer)
        "readonly", // boolean string, default is false   
        "theme" // "dark" | "light" (default is light)
    ];

    const stylesheet$2 = new CSSStyleSheet();
    stylesheet$2.replaceSync(`#scroll-container {
    overflow-x: auto;
    overflow-y: hidden;
    width: 100%;
    height: 50px;
    position: relative;
}

#status {
    position: absolute;
    width: 100%;
    height: 100%;
    background-color: #0009;
    top: 0;
    left: 0;
    z-index: 10;
    color: white;
    padding: 2rem;
    font-size: 15px;
    display: none;
}
#status.show { display: block; }

.dark #timeline { background-color: #414251; }
.light #timeline { background-color: #dce3ef; }


/* String foreground = "#ddd"; */
.playhead {
    /*        fill: #82838C; */
    fill: orange;
}

.dark .ruler { fill: #2E303F; }
.light .ruler { fill: transparent; }

.ruler-marks {
    text-anchor: start;
    font-family: 'Proxima Nova', sans-serif;
    font-size: 10px;
    dominant-baseline: middle;
    pointer-events: none;
    user-select: none;
}

.beat-line {
    stroke-opacity: 0.15;
    stroke-width: 1.0;
}

.beat-line.measure {
    stroke-opacity: 0.3;
    stroke-width: 2;
}

.dark .ruler-marks { fill: #ccc; }
.dark .beat-line { stroke: #ccc; }
.light .ruler-marks { fill: #000a; }
.light .beat-line { stroke: #000a; }


.timeline-waveform { fill: var(--piano-color); }
.piano .timeline-waveform { fill: var(--piano-color); }
.guitar .timeline-waveform { fill: var(--guitar-color); }
.marimba .timeline-waveform { fill: var(--marimba-color); }
.bass .timeline-waveform { fill: var(--bass-color); }
.drum .timeline-waveform { fill: var(--drum-color); }
.sound .timeline-waveform { fill: var(--sound-color); }

.waveline { stroke: black; stroke-width: 2; }`);

    var html$1 = "<div id=\"scroll-container\">\n    <div id=\"status\"></div>\n    <div id=\"container\" class=\"light\">\n        <svg id=\"timeline\" version=\"1.1\"></svg>\n    </div>\n</div>";

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    function isTimelineView(input) {
        return ['midi', 'waveform'].includes(input);
    }
    /**
     * Timeline can show midi piano roll or waveform view of audio
     *
     * <tunepad-timeline
     *     beats = "4"              // duration of the loop in beats (default 4)
     *     measure = "4"            // duration of each measure in beats (default 4)
     *     tempo = "90"             // bpm needed to scale waveforms correctly
     *     theme = "dark | light"   // default is light
     *     status = "{{message}}"   // show a status message and dim out current view
     *     view = "waveform">       // visualization "waveform" or "midi" (default waveform)
     */
    class Timeline extends HTMLElement {
        get beats() { return Math.max(this._beats, this.measure); }
        // how many pixels wide per quarter note
        get beatWidth() {
            return Math.max(40, this.width / this.beats);
        }
        // how many pixels wide for the entire trace
        get traceWidth() {
            return this.beatWidth * this.beats;
        }
        // pixels per second of audio
        get pixelsPerSecond() {
            return this.traceWidth / (this.beats * this.tempo / 60);
        }
        get scoreHeight() { return this.height - this.rulerHeight; }
        set waveform(wave) {
            this._waveform = wave;
            this.render();
        }
        constructor() {
            super();
            // attributes
            this._beats = 4;
            this.measure = 4; // duration of each measure in beats
            this.tempo = 90; // bpm
            this.view = "waveform";
            this.theme = "light";
            // dimensions of outer container
            this.width = 700;
            this.height = 100;
            // height of the top ruler
            this.rulerHeight = 20;
            this.root = this.attachShadow({ mode: 'open' });
            this.root.adoptedStyleSheets.push(stylesheet$2);
            this.root.adoptedStyleSheets.push(stylesheet$3);
            const template = document.createElement('template');
            template.innerHTML = html$1;
            this.root.appendChild(template.content.cloneNode(true));
            this.audio = TunePadAudio.init();
            this.svg = this.root.querySelector('#timeline');
        }
        beatToX(beat) {
            return beat * this.beatWidth;
        }
        connectedCallback() {
            // listen for resize events
            window.addEventListener('resize', (e) => this.render());
            this.render();
        }
        disconnectedCallback() {
            //console.log("Custom element removed from page.");
        }
        attributeChangedCallback(name, oldValue, newValue) {
            if (oldValue === newValue)
                return;
            if (name === 'beats') {
                this._beats = toInt(newValue, this.beats);
                this.render();
            }
            else if (name === 'measure') {
                this.measure = Math.max(1, toInt(newValue, this.measure));
                this.render();
            }
            else if (name === 'view' && isTimelineView(newValue)) {
                this.view = newValue;
                this.render();
            }
            else if (name === 'tempo') {
                this.tempo = toInt(newValue, this.tempo);
                this.render();
            }
            else if (name === 'theme' && ['dark', 'light'].includes(newValue)) {
                this.theme = newValue;
                this.root.querySelector('#container')?.classList.remove(oldValue);
                this.root.querySelector('#container')?.classList.add(newValue);
            }
            else if (name === 'status') {
                const status = this.root.querySelector('#status');
                if (status && newValue) {
                    status.innerHTML = newValue;
                    status.classList.add('show');
                }
                else if (status) {
                    status.innerHTML = '';
                    status.classList.remove('show');
                }
            }
        }
        /**
         * (Re)draw the timeline
         */
        render() {
            this.resize();
            this.svg.innerHTML = '';
            const group = document.createElementNS("http://www.w3.org/2000/svg", 'g');
            const ruler = this.renderRuler();
            group.append(ruler);
            if (this._waveform) {
                group.append(this.renderWaveform(this._waveform));
            }
            this.svg.append(group);
        }
        renderRuler() {
            const beatNumbers = document.createElementNS("http://www.w3.org/2000/svg", 'g');
            // background rect
            const beatBacker = document.createElementNS("http://www.w3.org/2000/svg", 'rect');
            beatBacker.classList.add('ruler');
            beatBacker.setAttribute('x', `${this.beatToX(0)}`);
            beatBacker.setAttribute('y', '0');
            beatBacker.setAttribute('width', `${this.traceWidth}`);
            beatBacker.setAttribute('height', `${this.rulerHeight}`);
            beatNumbers.append(beatBacker);
            /*
            beatBacker.onMouseDown.listen((MouseEvent e) {
              _down = true;
              playhead = xToBeat(e.client.x);
              listener.onMovePlayhead(_playhead);
              _dragging = true;
            });
            */
            for (let i = 1; i <= this.beats; i++) {
                let x = this.beatToX(i - 1);
                const text = document.createElementNS("http://www.w3.org/2000/svg", 'text');
                text.classList.add('ruler-marks');
                text.setAttribute('x', `${x + 5}`);
                text.setAttribute('y', `${this.rulerHeight / 2}`);
                text.innerHTML = (i === 1) ? "BEAT" : `${i}`;
                beatNumbers.append(text);
                if (i === 1)
                    continue;
                const line = document.createElementNS("http://www.w3.org/2000/svg", 'line');
                line.classList.add('beat-line');
                line.setAttribute('x1', `${x}`);
                line.setAttribute('y1', '0');
                line.setAttribute('x2', `${x}`);
                line.setAttribute('y2', `${this.height}`);
                // make first beat of each measure thicker
                if ((i - 1) % this.measure === 0) {
                    line.classList.add('measure');
                }
                beatNumbers.append(line);
            }
            return beatNumbers;
        }
        /**
         * Creates SVG path that visualizes the waveform
         */
        renderWaveform(wave) {
            /*
            const group = wave.wavelines;
            group.setAttribute(
                "transform",
                `translate(0, ${this.height / 2}), ` +
                `scale(${this.pixelsPerSecond}, ${this.scoreHeight / 2})`
            );
            return group;
            */
            const group = document.createElementNS("http://www.w3.org/2000/svg", 'g');
            const path = wave.wavepath;
            if (path) {
                path.classList.add("timeline-waveform");
                group.setAttribute("transform", `translate(0, ${this.height / 2}), ` +
                    `scale(${this.pixelsPerSecond}, ${this.scoreHeight / 2})`);
                group.append(path);
            }
            return group;
        }
        /**
         * Called when the window and possibly containing element are resized.
         */
        resize() {
            const scrollContainer = this.root.querySelector('#scroll-container');
            const container = this.root.querySelector('#container');
            if (container && scrollContainer) {
                this.width = scrollContainer.getBoundingClientRect().width;
                this.height = scrollContainer.getBoundingClientRect().height;
                console.log(this.width, this.height);
                container.style.width = `${this.traceWidth}px`;
                this.svg.setAttribute("viewBox", `0 0 ${this.traceWidth} ${this.height}`);
            }
        }
    }
    Timeline.ELEMENT = "tunepad-timeline";
    Timeline.observedAttributes = [
        "beats", // duration of the loop in beats (default 4)
        "measure", // duration of each measure in beats (default 4)
        "tempo", // bpm
        "theme", // "dark" | "light"
        "status", // message on progress
        "view" // visualization "waveform" or "midi"
    ];

    const stylesheet$1 = new CSSStyleSheet();
    stylesheet$1.replaceSync(`.cell-wrapper {
    border-radius: 10px;
    max-width: 750px;
    min-width: 400px;
    padding: 0 8px;
    background-color: #946161;
    position: relative;
}

header {
    background-color: var(--cell-header-bg-color);
    height: 60px;
    border-top: 2px solid #667;
    border-bottom: 2px solid #667;
    border-left: 2px solid #414252;
    border-right: 2px solid #414252;
    padding: 10px 10px 10px 15px;
    box-sizing: border-box;
    display: flex;
}

.gadget-icon {
    width: 35px;
    height: 35px;
    background-color: var(--piano-color);
    border-radius: 50%;
    margin-right: 10px;
    background-image: url(/assets/images/instruments/synth.svg);
    background-size: 70%;
    background-repeat: no-repeat;
    background-position: center;
}
.definitions .gadget-icon {
    background-color: var(--definitions-color);
    background-image: url(/assets/images/instruments/definitions.svg);
}
.piano .gadget-icon {
    background-color: var(--piano-color);
    background-image: url(/assets/images/instruments/synth.svg);
}
.bass .gadget-icon {
    background-color: var(--bass-color);
    background-image: url(/assets/images/instruments/bass.svg);
}
.guitar .gadget-icon {
    background-color: var(--guitar-color);
    background-image: url(/assets/images/instruments/guitar.svg);
}
.marimba .gadget-icon {
    background-color: var(--marimba-color);
    background-image: url(/assets/images/instruments/marimba.svg);
}
.drums .gadget-icon, .drumkit .gadget-icon {
    background-color: var(--drum-color);
    background-image: url(/assets/images/instruments/drumkit.svg);
}
.sampler .gadget-icon {
    background-color: var(--sound-color);
    background-image: url(/assets/images/instruments/voxel.svg);
}
.sound .gadget-icon {
    background-color: var(--sound-color);
    background-image: url(/assets/images/instruments/sampler.svg);
}

header .gadget-name {
    width: 100%;
    max-width: 450px;
    color: white;
    font-weight: bold;
    font-family: var(--main-font);
    font-size: 15px;
    border: 1px solid transparent;
    outline: none;
    background-color: transparent;
    padding: 2px 5px;
    position: relative;
    top: -5px;
    border-radius: 3px;
}
header .gadget-name:hover {
    background-color: #fff2;
    border: 1px solid #fff6;
}
header .gadget-name:focus {
    background-color: #fffd;
    color: #333;
    font-weight: normal;
    border: 1px solid black;
}
header .gadget-info {
    color: #fff8;
    font-size: 11px;
    font-weight: normal;
    padding-left: 7px;
    position: relative;
    top: -8px;
}
#uncompiled {
    color: white;
    font-weight: bold;
    font-size: 120%;
}

.badges {
    display: flex;
    align-items: center;
}
.badge {
    min-width: 30px;
    text-align: center;
    margin: 0 0.25rem;
}
.badge svg { 
    width: 25px;
    height: 25px;
    vertical-align: middle;
}
.badge#error-badge svg { fill: var(--error-badge-color); }
.badge#warning-badge svg { fill: var(--warn-badge-color); }
.badge#pass-badge svg,
.badge#fail-badge svg { 
    fill: white; 
    width: 15px; height: 15px;
    position: relative;
    top: -1px;
}
.badge#pass-badge {
    background-color: var(--pass-badge-color);
    border-radius: 0.75em;
    padding: 0.2em 0.4em;
    color: white;
}
.badge#fail-badge {
    background-color: var(--fail-badge-color);
    border-radius: 0.75em;
    padding: 0.2em 0.4em;
    color: white;
}
.badge#output-badge { 
    background-color: var(--output-badge-color);
    color: white;
    border-radius: 0.75em;
    min-width: 1.5em;
    padding: 0.2em 0.4em;
}
.badge.hidden { display: none; }

footer, .toolbar {
    display: flex;
    background-color: #535563;
    border-left: 2px solid #414252;
    border-right: 2px solid #414252;
    color: #fffc;
}
.toolbar {
    padding: 8px 10px;
    line-height: 34px;
}

.expander { flex: 1; }

.toolbar button {
    outline: none;
    border: 2px solid #9194A1;
    color: rgba(255, 255, 255, 0.75);
    background-color: #fff2;
    box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.1);
    width: 40px;
    height: 35px;
    border-radius: 5px;
    margin: 3px;
    font-size: 14px;
    text-align: center;
    white-space: nowrap;
    transition: all 100ms ease-out;
}
.toolbar button svg { 
    width: 17px;
    height: 17px; 
    fill: rgba(255, 255, 255, 0.75);; 
    vertical-align: middle;
}
.toolbar button:active { background-color: rgba(255, 255, 255, 0.45); }
.toolbar button:hover { border: 2px solid #DDD; }
.toolbar button.hidden { display: none; }
.toolbar button:disabled svg { fill: #fff3; }
.toolbar button:disabled:hover { border: 2px solid #9194A1; }
.toolbar button:disabled:active { background-color: #fff2; }

#loader svg {
    animation: spin-animation 2s infinite;
    animation-timing-function: linear;
}

.cell-contents {
    padding: 0 12px;
    border-left: 2px solid #414252;
    border-right: 2px solid #414252;
    background-color: #535563;
    position: relative;
}
#cell-instrument {
    padding: 0;
    border-left: 2px solid #414252;
    border-right: 2px solid #414252;
    background-color: #535563;
    position: relative;
}
.definitions #cell-instrument {
    display: none;
}
.definitions #instrument-tools {
    display: none;
}
footer {
    padding: 3px 20px;
    align-items: center;
}

footer button {
    outline: none;
    border: none;
    color: rgba(255, 255, 255, 0.75);
    width: 40px;
    height: 30px;
    font-size: 14px;
    background-color: transparent;
}
footer button svg { 
    width: 16px;
    height: 16px; 
    fill: rgba(255, 255, 255, 0.7);
    vertical-align: middle;
}
footer button:hover svg { fill: rgba(255, 255, 255, 0.8); }
footer button:active svg { fill: rgba(255, 255, 255, 0.9); }
.module-name {
    font-family: monospace;
    font-weight: normal;
    font-size: 11px;
    color: #fffc;
    flex: 1;
    text-align: left;
    display: none;
}
.definitions .module-name { display: block; }

.autocompile-status {
    font-size: 90%;
    text-align: right;
    flex: 1;
}

#loader-background {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 100;
    background-color: #000a;
    display: none;
    align-items: center;
    border-radius: 10px;
}
#loader-background.show {
    display: flex;
}
.loader-text {
    color: white;
    text-align: center;
    flex: 1;
    font-size: 110%;
}
#loader-background img {
    display: block;
    margin: 1rem auto;
    width: 90px;
}

#last-saved {
    text-align: right;
    font-size: 11px;
    margin-top: 0.25rem;
    color: #444;
}

@media print {
    .buttons { display: none; }
}

@keyframes spin-animation {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(359deg);
    }
}
`);

    const stylesheet = new CSSStyleSheet();
    stylesheet.replaceSync(`
.drop-menu {
    position: absolute;
    background-color: white;
    border: 1px solid #0001;
    border-radius: 8px;
    padding: 8px 0;
    z-index: 100;
    display: flex;
    flex-direction: column;
    min-width: 200px;
    box-shadow: 0px 3px 5px #0005;
    -webkit-touch-callout: none;
    user-select: none;
    margin: 0;
}
.drop-menu.hidden { display: none; }
.drop-menu:hover { cursor: pointer; }
.drop-menu.terminal {
    max-height: 70vh;
    overflow-y: auto !important;
}
.menu-item {
    line-height: 140%;
    display: flex;
    align-items: center;
    font-size: 14px;
    font-weight: normal;
    color: #3C4E60;
    outline: none;
    border: none;
    padding: 5px 20px 5px 10px;
    white-space: nowrap;
    position: relative;
    text-align: left;
}
.menu-item:hover { background: rgba(0, 0, 0, 0.15); }
.menu-item:not(:has(.drop-menu)):active { background: rgba(0, 0, 0, 0.2); }
.menu-item.highlight { background: rgba(0, 0, 0, 0.085); }
.menu-item.disabled { color: #aaa; }
.menu-item.disabled:hover { background-color: transparent; }
.menu-item.disabled:active { background-color: transparent; }
.menu-item.disabled .icon { opacity: 0.3; }
.menu-item.hidden { display: none; }

.menu-item:hover > .drop-menu {
  display: flex;
  left: 88%;
  top: -10px;
}

.menu-item .icon {
    width: 1.1rem;
    height: 1.1rem;
    margin: 0 0.85rem 0 0.5rem;
    text-align: center;
    opacity: 0.6;
    background-repeat: no-repeat;
    background-size: contain;
    background-position: center;
}
.menu-item .expand {
  text-align: right;
  position: relative;
  left: 5px;
  font-size: 90%;
  width: 2em;
  flex: 1;
}
.menu-item .name {
  flex: 1;
}
.menu-item .expand::before {
  content: "▸";
  font-size: 17px;
  color: rgba(0,0,0,0.6);
  font-weight: 600;
}
.menu-separator {
    border-top: 1px solid #0005;
    margin: 10px;
    height: 2px;
}`);

    var html = "<div class=\"cell-wrapper definitions\">\n    <header>\n        <div class=\"gadget-icon\"></div>\n        <div style=\"flex: 1;\">\n            <input class=\"gadget-name\">\n            <div class=\"gadget-info\">\n                <span id=\"line-count\"></span>\n                <span id=\"uncompiled\"></span>\n            </div>\n        </div>\n        <div class=\"badges\">\n            <div id=\"error-badge\" class=\"badge hidden\">\n                <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                    <circle cx=\"256\" cy=\"256\" r=\"250\" fill=\"white\"/>\n                    <path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm0-384c13.3 0 24 10.7 24 24V264c0 13.3-10.7 24-24 24s-24-10.7-24-24V152c0-13.3 10.7-24 24-24zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z\"/>\n                </svg>\n            </div>\n            <div id=\"warning-badge\" class=\"badge hidden\">\n                <svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 512 512\">\n                    <path fill=\"white\" d=\"M258,108c10.5,0,20.3,5.6,25.6,14.7l160.3,273.1c5.4,9.2,5.4,20.6.1,29.8s-15.1,14.9-25.8,14.9H97.7c-10.6,0-20.5-5.7-25.8-14.9s-5.2-20.6.1-29.8L232.4,122.7c5.3-9.1,15.1-14.7,25.6-14.7Z\"/>\n                    <path d=\"M256,32c14.2,0,27.3,7.5,34.5,19.8l216,368c7.3,12.4,7.3,27.7.2,40.1s-20.4,20.1-34.7,20.1H40c-14.3,0-27.6-7.7-34.7-20.1s-7-27.8.2-40.1L221.5,51.8c7.2-12.3,20.3-19.8,34.5-19.8ZM256,160c-13.3,0-24,10.7-24,24v112c0,13.3,10.7,24,24,24s24-10.7,24-24v-112c0-13.3-10.7-24-24-24ZM288,384c0-17.7-14.3-32-32-32s-32,14.3-32,32,14.3,32,32,32,32-14.3,32-32Z\"/>\n                </svg>\n            </div>\n            <div id=\"pass-badge\" class=\"badge hidden\">\n                <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                    <path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM369 209L241 337c-9.4 9.4-24.6 9.4-33.9 0l-64-64c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l47 47L335 175c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9z\"/>\n                </svg>\n                <span id=\"pass-count\"></span>\n            </div>\n            <div id=\"fail-badge\" class=\"badge hidden\">\n                <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                    <path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM175 175c9.4-9.4 24.6-9.4 33.9 0l47 47 47-47c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6 0-33.9z\"/>\n                </svg>\n                <span id=\"fail-count\"></span>\n            </div>\n            <div id=\"output-badge\" class=\"badge hidden\"></div>\n        </div>\n    </header>\n    <div class=\"toolbar\">\n        <button id=\"loader\" title=\"Recompiling\" disabled=\"disabled\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                <path d=\"M304 48a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zm0 416a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM48 304a48 48 0 1 0 0-96 48 48 0 1 0 0 96zm464-48a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM142.9 437A48 48 0 1 0 75 369.1 48 48 0 1 0 142.9 437zm0-294.2A48 48 0 1 0 75 75a48 48 0 1 0 67.9 67.9zM369.1 437A48 48 0 1 0 437 369.1 48 48 0 1 0 369.1 437z\"/>\n            </svg>\n        </button>\n        <button id=\"compile-button\" class=\"hidden\" title=\"Compile\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                <path d=\"M105.1 202.6c7.7-21.8 20.2-42.3 37.8-59.8c62.5-62.5 163.8-62.5 226.3 0L386.3 160H352c-17.7 0-32 14.3-32 32s14.3 32 32 32H463.5c0 0 0 0 0 0h.4c17.7 0 32-14.3 32-32V80c0-17.7-14.3-32-32-32s-32 14.3-32 32v35.2L414.4 97.6c-87.5-87.5-229.3-87.5-316.8 0C73.2 122 55.6 150.7 44.8 181.4c-5.9 16.7 2.9 34.9 19.5 40.8s34.9-2.9 40.8-19.5zM39 289.3c-5 1.5-9.8 4.2-13.7 8.2c-4 4-6.7 8.8-8.1 14c-.3 1.2-.6 2.5-.8 3.8c-.3 1.7-.4 3.4-.4 5.1V432c0 17.7 14.3 32 32 32s32-14.3 32-32V396.9l17.6 17.5 0 0c87.5 87.4 229.3 87.4 316.7 0c24.4-24.4 42.1-53.1 52.9-83.7c5.9-16.7-2.9-34.9-19.5-40.8s-34.9 2.9-40.8 19.5c-7.7 21.8-20.2 42.3-37.8 59.8c-62.5 62.5-163.8 62.5-226.3 0l-.1-.1L125.6 352H160c17.7 0 32-14.3 32-32s-14.3-32-32-32H48.4c-1.6 0-3.2 .1-4.8 .3s-3.1 .5-4.6 1z\"/>\n            </svg>\n        </button>\n        <div class=\"expander\"></div>\n        <button id=\"theme-button\" title=\"Toggle Dark Mode\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                <path d=\"M448 256c0-106-86-192-192-192V448c106 0 192-86 192-192zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256z\"/>\n            </svg>\n        </button>\n        <div class=\"menu-container\">\n            <button id=\"menu-trigger\" title=\"Cell Menu...\">\n                <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 448 512\">\n                    <path d=\"M8 256a56 56 0 1 1 112 0A56 56 0 1 1 8 256zm160 0a56 56 0 1 1 112 0 56 56 0 1 1 -112 0zm216-56a56 56 0 1 1 0 112 56 56 0 1 1 0-112z\"/>\n                </svg>\n            </button>\n            <context-menu>\n                <context-menu-item action=\"copy\" name=\"Copy Cell\" icon=\"/images/copy-icon.svg\" disabled=\"true\"></context-menu-item>\n                <context-menu-item action=\"delete\" name=\"Delete Cell\" icon=\"/images/trash-icon.svg\" disabled=\"true\"></context-menu-item>\n                <div class=\"menu-separator\"></div>\n                <context-menu-item action=\"autocomp\" checked=\"false\" name=\"Autocompile\" id=\"autocomp\"></context-menu-item>\n                <!-- <context-menu-item action=\"readonly\" checked=\"false\" name=\"Readonly\" id=\"readonly\"></context-menu-item> -->\n            </context-menu>\n        </div>\n    </div>\n    <div class=\"cell-contents\"></div>\n    <div class=\"toolbar\" id=\"instrument-tools\">\n        <div class=\"menu-container\">\n            <button id=\"instrument-menu-trigger\" title=\"Instrument Menu...\">\n                <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 448 512\">\n                    <path d=\"M8 256a56 56 0 1 1 112 0A56 56 0 1 1 8 256zm160 0a56 56 0 1 1 112 0 56 56 0 1 1 -112 0zm216-56a56 56 0 1 1 0 112 56 56 0 1 1 0-112z\"/>\n                </svg>\n            </button>\n            <context-menu>\n                <context-menu-item action=\"bass\" name=\"Bass\" checked=\"false\"></context-menu-item>\n                <context-menu-item action=\"drums\" name=\"Drum Pad\" checked=\"false\"></context-menu-item>\n                <context-menu-item action=\"marimba\" name=\"Marimba\" checked=\"false\"></context-menu-item>\n                <context-menu-item action=\"piano\" name=\"Piano\" checked=\"false\"></context-menu-item>\n                <context-menu-item action=\"guitar\" name=\"Guitar\" checked=\"false\"></context-menu-item>\n            </context-menu>\n        </div>\n    </div>\n    <div id=\"cell-instrument\">\n        <piano-instrument patch=\"/assets/sounds/voices/grand-piano/\" key-range=\"17\"></piano-instrument>\n    </div>\n    <footer>\n        <div class=\"module-name\">\n            <span id=\"import-text\"></span>\n            <button id=\"copy-button\" title=\"Copy to Clipboard\">\n                <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 448 512\">\n                    <path d=\"M384 336H192c-8.8 0-16-7.2-16-16V64c0-8.8 7.2-16 16-16l140.1 0L400 115.9V320c0 8.8-7.2 16-16 16zM192 384H384c35.3 0 64-28.7 64-64V115.9c0-12.7-5.1-24.9-14.1-33.9L366.1 14.1c-9-9-21.2-14.1-33.9-14.1H192c-35.3 0-64 28.7-64 64V320c0 35.3 28.7 64 64 64zM64 128c-35.3 0-64 28.7-64 64V448c0 35.3 28.7 64 64 64H256c35.3 0 64-28.7 64-64V416H272v32c0 8.8-7.2 16-16 16H64c-8.8 0-16-7.2-16-16V192c0-8.8 7.2-16 16-16H96V128H64z\"/>\n                </svg>\n            </button>\n        </div>\n        <div class=\"autocompile-status\"></div>\n    </footer>\n    <div id=\"loader-background\">\n        <div style=\"width: 100%;\">\n            <img src=\"/assets/images/animated_bars.svg\" alt=\"\">\n            <div class=\"loader-text\"></div>\n        </div>\n    </div>\n</div>\n<div id=\"last-saved\"></div>";

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    /**
     * ## TunePad definitions cell.
     * ```html
     * <tunepad-code-cell
     *    uuid = "{{ database UUID }}"
     *    name = "{{ python module name }}"  // must be a valid python identifier
     *    readonly = "true" | "false"        // default is false
     *    autocompile = "true" | "false"     // default is false... compile on line edits
     *    theme = "dark" | "light">          // default is light
     * playNote(30)  # default Python code here...
     * </tunepad-code-cell>
     * ```
     *
     * ### HACK FIX FOR MARKDOWN:
     * If you're formatting code in a markdown file and you have blank lines in your code, insert
     * a single forward slash in place of a blank line
     * ```html
     * <tunepad-code-cell>
     * C = 60
     * /
     * playNote(C)
     * </tunepad-code-cell>
     * ```
     */
    class CodeCell extends HTMLElement {
        /** contents of the code editor */
        get code() { return this.editor.code; }
        constructor() {
            super();
            /** GUID sent to the python compiler */
            this.uuid = self.crypto.randomUUID();
            /** python "file" name corresponds to the id attribute */
            this.name = 'tunepad_code';
            /** automatically compile after line edits */
            this.autocompile = false;
            /** code changed */
            this.codeChanged = false;
            /** which virtual instrument to show (piano, bass, guitar, drums) */
            this.instrument = 'definitions';
            this.root = this.attachShadow({ mode: 'open' });
            this.root.adoptedStyleSheets.push(stylesheet$3);
            this.root.adoptedStyleSheets.push(stylesheet$1);
            this.root.adoptedStyleSheets.push(stylesheet);
            this.root.innerHTML = html;
            this.editor = document.createElement("tunepad-python-editor");
            this.editor.setAttribute('uuid', this.uuid);
            this.editor.setAttribute('name', this.name);
            this.nameField = this.root.querySelector('.gadget-name');
            PythonRuntime.init();
            this.state = document.createElement('cell-state');
        }
        connectedCallback() {
            this.showLoader('Loading cell data...');
            // load state from the datastore
            window.addEventListener('load', () => { this.loadState(); });
            this._bindUserEvents();
        }
        async loadState() {
            this.state.setAttribute('cell-id', this.uuid);
            this.state.setAttribute('project-id', 'test-project3');
            //this.state.setAttribute('wss', 'wss://tunepad.space/websocket/');
            this.root.appendChild(this.state);
            this.editor.innerHTML = '';
            await this.state.connectToDatastore();
            // update cell to match the datastore
            if (this.state.existed) {
                this.setName(toStr(this.state.get('name'), 'tunepad_cell'));
                this.setAutoCompile(toBool(this.state.get('settings-autocompile'), false));
                this.setTheme(toStr(this.state.get('settings-theme'), 'light'));
                this.setReadOnly(toBool(this.state.get('settings-readonly'), false));
                this.setInstrument(toStr(this.state.get('instrument'), 'piano'));
                this.editor.initialContent = this.state.content;
            }
            // or create default state
            else {
                this.state.set('name', this.name);
                this.state.set('settings-autocompile', this.autocompile);
                this.state.set('settings-theme', toStr(this.getAttribute('theme'), 'light'));
                this.state.set('settings-readonly', toBool(this.getAttribute('readonly'), false));
                this.state.set('instrument', toStr(this.getAttribute('instrument'), 'piano'));
                this.state.content = this.innerHTML;
                this.editor.initialContent = this.innerHTML
                    .trim()
                    .split('\n')
                    .map((line) => line.startsWith('/') ? line.substring(1) : line) // ugly markdown hack
                    .join('\n');
            }
            this.state.bindEditor(this.editor);
            // insert codemirror editor
            this.root.querySelector('.cell-contents')?.appendChild(this.editor);
            // initial code compile
            this.setHTML('#line-count', 'LOADING PYTHON...');
            this.setHTML('#uncompiled', '');
            this.recompile();
            this.hideLoader();
            this.state.addEventListener('datastore-event', (evt) => {
                const { event, message } = evt.detail;
                if (event === 'connection-error') {
                    this.showLoader(message);
                }
                else if (event === 'connected') {
                    this.hideLoader();
                }
                else if (event === 'synced') {
                    this.hideLoader();
                }
            });
            // listen for datastore events
            this.state.addEventListener('datastate-event', (evt) => {
                const { action, key, newValue, oldValue } = evt.detail;
                if (action === 'update') {
                    this.setHTML('#last-saved', `Last saved: ${new Date().toLocaleString()}`);
                    if (key === 'name') {
                        this.setName(newValue);
                    }
                    else if (key === 'settings-autocompile') {
                        this.setAutoCompile(toBool(newValue, false));
                    }
                    else if (key === 'settings-theme') {
                        this.setAttribute('theme', newValue);
                    }
                    else if (key === 'settings-readonly') {
                        this.setReadOnly(toBool(newValue, false));
                    }
                }
            });
        }
        setName(name) {
            if (name === this.name)
                return;
            this.name = PythonRuntime.makePythonSafe(name, this.uuid);
            PythonRuntime.renameCell(this);
            this.nameField.value = this.name;
            this.editor.setAttribute('name', this.name);
            this.setHTML('#import-text', `from ${this.name} import *`);
            this.setAttribute('name', this.name);
        }
        setAutoCompile(on) {
            if (on === this.autocompile)
                return;
            this.autocompile = on;
            this.root.querySelector('#autocomp')?.setAttribute('checked', `${on}`);
            this.setAttribute('autocompile', `${on}`);
            this.setHTML('.autocompile-status', on ? 'Autocompile' : '');
        }
        setReadOnly(ro) {
            this.setAttribute('readonly', `${ro}`);
            this.editor.setAttribute('readonly', `${ro}`);
            this.nameField.readOnly = ro;
            this.root.querySelector('#readonly')?.setAttribute('checked', `${ro}`);
        }
        setTheme(theme) {
            if (['light', 'dark'].includes(theme))
                this.setAttribute('theme', theme);
        }
        setInstrument(instrument) {
            this.removeClass('.cell-wrapper', this.instrument);
            this.instrument = instrument;
            this.addClass('.cell-wrapper', this.instrument);
        }
        disconnectedCallback() {
            PythonRuntime.removeWarningListener(this.uuid);
        }
        attributeChangedCallback(name, oldValue, newValue) {
            if (name === 'uuid') {
                this.uuid = newValue;
                this.editor.setAttribute('uuid', this.uuid);
            }
            else if (name === 'name') {
                this.setName(newValue);
            }
            else if (name === 'readonly' && newValue != oldValue) {
                this.setReadOnly(newValue === 'true');
            }
            else if (name === 'theme') {
                this.editor.setAttribute('theme', newValue);
            }
            else if (name === 'autocompile' && newValue != oldValue) {
                this.setAutoCompile(newValue === 'true');
            }
            else if (name === 'instrument' && newValue != oldValue) {
                this.setInstrument(newValue);
            }
        }
        /**
         * Trigger a python compile and display any errors, warnings, messages, or print outputs
         * that result.
         */
        async recompile() {
            this.addClass('#compile-button', 'hidden');
            this.removeClass('#loader', 'hidden');
            // compile the python code
            const resp = await this.editor.recompile();
            // turn on badges
            this.setHTML('#output-badge', `${resp.output.length}`);
            this.setHTML('#fail-count', `${resp.trace.fails.length}`);
            this.setHTML('#pass-count', `${resp.trace.passes.length}`);
            this.setClass('#output-badge', 'hidden', resp.output.length === 0);
            this.setClass('#error-badge', 'hidden', resp.hasNoErrors);
            this.setClass('#fail-badge', 'hidden', resp.trace.fails.length === 0);
            this.setClass('#pass-badge', 'hidden', resp.trace.passes.length === 0);
            // reactivate compile button
            this.removeClass('#compile-button', 'hidden');
            this.addClass('#loader', 'hidden');
            this.setHTML('#uncompiled', '');
            this.codeChanged = false;
            //this.root.querySelector('#compile-button')?.setAttribute('disabled', 'true');
            // update line count
            this.setHTML('#line-count', `${this.editor.code.split('\n').length} LINES`);
        }
        showLoader(message) {
            this.setHTML('.loader-text', message);
            this.addClass('#loader-background', 'show');
        }
        hideLoader() {
            this.setHTML('.loader-text', '');
            this.removeClass('#loader-background', 'show');
        }
        _bindUserEvents() {
            // listen for warnings from the compiler
            PythonRuntime.addWarningListener(this.uuid, (warns) => {
                this.setClass('#warning-badge', 'hidden', warns.length === 0);
                this.editor.warnings = warns;
            });
            // listen for editor change events
            this.editor.addEventListener('codemirror-event', (e) => {
                switch (e.detail.event) {
                    case 'lines-inserted':
                    case 'lines-removed':
                        if (this.autocompile)
                            this.recompile();
                        break;
                    case 'cursor-moved':
                        if (this.autocompile && this.codeChanged)
                            this.recompile();
                        break;
                    case 'editor-blur':
                        if (this.codeChanged) {
                            this.state?.set('modified', Date.now());
                            this.recompile();
                        }
                        break;
                    case 'content-changed':
                        this.setHTML('#uncompiled', '*');
                        this.codeChanged = true;
                        break;
                }
            });
            this.root.querySelector('#copy-button')?.addEventListener('click', e => {
                navigator.clipboard.writeText(`from ${this.name} import *`);
            });
            this.root.querySelector('#theme-button')?.addEventListener('click', e => {
                const theme = (this.getAttribute('theme') === 'dark') ? 'light' : 'dark';
                this.setAttribute('theme', theme);
                this.state?.set('settings-theme', theme);
            });
            // fire recompile when the compile button is pressed...
            this.root.querySelector('#compile-button')?.addEventListener('click', e => {
                this.setHTML('#line-count', 'COMPILING...');
                this.state?.set('modified', Date.now());
                this.recompile();
            });
            // context menu events
            this.root.addEventListener('context-menu-action', (e) => {
                const action = e.detail.action;
                if (action === 'autocomp') {
                    this.setAutoCompile(e.detail.origin.checked);
                    this.state?.set('settings-autocompile', this.autocompile);
                }
                else if (action === 'readonly') {
                    this.setReadOnly(e.detail.origin.checked);
                    this.state?.set('settings-readonly', e.detail.origin.checked);
                }
            });
            // cell name field
            this.nameField.addEventListener('blur', (e) => {
                this.setName(this.nameField.value);
                this.state?.set('name', this.name);
            });
            this.nameField.addEventListener('keypress', (e) => {
                if (e.key === "Enter") {
                    this.nameField.blur();
                }
            });
        }
        setClass(selector, className, on) {
            on ? this.addClass(selector, className) : this.removeClass(selector, className);
        }
        addClass(selector, className) {
            const e = this.root.querySelector(selector);
            if (e && className)
                e.classList.add(className);
        }
        removeClass(selector, className) {
            const e = this.root.querySelector(selector);
            if (e && className)
                e.classList.remove(className);
        }
        setHTML(selector, value) {
            const e = this.root.querySelector(selector);
            if (e)
                e.innerHTML = value;
        }
    }
    CodeCell.ELEMENT = "tunepad-code-cell";
    CodeCell.observedAttributes = [
        "uuid", // database ID (should never change)
        "name", // page-unique id for this code snippet (must be valid python identifer)
        "readonly", // boolean string, default is false
        "autocompile", // boolean (compile on line edits, default is false)
        "theme", // "dark" | "light" (default is light)
        "instrument" // "piano", "bass", "guitar", "drums"
    ];

    /*
     * TunePad
     *
     * Michael S. Horn
     * Northwestern University
     * michael-horn@northwestern.edu
     * Copyright 2024, Michael S. Horn
     *
     * This project was funded by the National Science Foundation (grant DRL-1612619).
     * Any opinions, findings and conclusions or recommendations expressed in this
     * material are those of the author(s) and do not necessarily reflect the views
     * of the National Science Foundation (NSF).
     */
    /**
     * ## Creates a dropdown context menu.
     * The inner HTML should contain a ul.drop-menu list.
     * The onSelected function takes an HtmlElement .menu-item that gets selected
     * by the user. Typically, the action code for a menu is stored in an HTML
     * data attribute. Multi-level menus are supported:
     *
     * ```html
     * <context-menu>
     *     <context-menu-item action="export" icon="export.svg" disabled="true" name="Export"></context-menu-item>
     *     <div class="menu-separator"></div>
     *     <context-menu-item name="Options">
     *         <context-menu>
     *             <context-menu-item action="theme">Dark Mode<context-menu-item>
     *        </context-menu>
     *    </context-menu-item>
     * </context-menu>
     * ```
     */
    class ContextMenu extends HTMLElement {
        constructor() {
            super();
            this.classList.add('drop-menu', 'hidden');
        }
        emitEvent(name) {
            this.dispatchEvent(new CustomEvent(name, { bubbles: true, composed: true, detail: { origin: this } }));
        }
        async connectedCallback() {
            const container = this.parentElement;
            container.addEventListener('pointerdown', (e) => {
                this.classList.toggle('hidden');
                e.stopPropagation();
                this.emitEvent('context-menu-open');
            });
            document.addEventListener('pointerdown', (e) => {
                this.classList.add('hidden');
            });
            document.addEventListener('context-menu-open', (e) => {
                const origin = e.detail.origin;
                if (origin !== this)
                    this.classList.add('hidden');
            });
            this.addEventListener('context-menu-action', (e) => {
                this.classList.add('hidden');
            });
        }
    }
    ContextMenu.ELEMENT = "context-menu";
    class ContextMenuItem extends HTMLElement {
        constructor() {
            super();
            this.disabled = false;
            this.classList.add('menu-item');
            this.name = document.createElement('div');
            this.name.classList.add('name');
            this.icon = document.createElement('div');
            this.icon.classList.add('icon');
            this.expand = document.createElement('div');
            this.expand.classList.add('expand');
        }
        emitEvent(name) {
            this.dispatchEvent(new CustomEvent(name, {
                bubbles: true,
                composed: true,
                detail: {
                    origin: this,
                    action: this.getAttribute('action'),
                    checked: this.checked
                }
            }));
        }
        async connectedCallback() {
            this.appendChild(this.icon);
            this.appendChild(this.name);
            const submenu = this.querySelector('context-menu');
            if (submenu)
                this.appendChild(this.expand);
            this.addEventListener('pointerdown', (e) => e.stopPropagation());
            this.addEventListener('pointerup', (e) => {
                if (!this.disabled && !submenu) {
                    this.toggleChecked();
                    setTimeout(() => this.emitEvent('context-menu-action'), 100);
                }
            });
        }
        attributeChangedCallback(name, oldValue, newValue) {
            if (name === 'name') {
                this.name.innerHTML = newValue;
            }
            else if (name === 'icon') {
                this.icon.style.backgroundImage = `url(${newValue})`;
            }
            else if (name === 'disabled') {
                this.disabled = (newValue === 'true');
                this.classList.toggle('disabled', this.disabled);
            }
            else if (name === 'checked') {
                this.setChecked(newValue === 'true');
            }
        }
        toggleChecked() {
            if (this.hasAttribute('radio-group')) {
                const grp = this.getAttribute('radio-group');
                this.parentElement?.querySelectorAll(`.menu-item[radio-group=${grp}]`)
                    .forEach(item => item.setChecked(item == this));
            }
            else if (this.checked === undefined) {
                this.setChecked(undefined);
            }
            else if (this.checked === true) {
                this.setChecked(false);
            }
            else {
                this.setChecked(true);
            }
        }
        setChecked(checked) {
            this.checked = checked;
            this.icon.style.backgroundImage = this.checked ? 'url(/assets/images/check-icon.svg)' : 'none';
        }
    }
    ContextMenuItem.ELEMENT = "context-menu-item";
    ContextMenuItem.observedAttributes = ["name", "icon", "action", "disabled", "checked"];

    customElements.define(Piano.ELEMENT, Piano);
    customElements.define(PianoKeyboard.ELEMENT, PianoKeyboard);
    customElements.define(NoteExplorer.ELEMENT, NoteExplorer);
    customElements.define(TunePadCodeView.ELEMENT, TunePadCodeView);
    customElements.define(Timeline.ELEMENT, Timeline);
    customElements.define(TunePadPythonEditor.ELEMENT, TunePadPythonEditor);
    customElements.define(CodeCell.ELEMENT, CodeCell);
    customElements.define(ContextMenu.ELEMENT, ContextMenu);
    customElements.define(ContextMenuItem.ELEMENT, ContextMenuItem);
    PythonMessage.DefineElement();
    PythonOutput.DefineElement();

    exports.AudioLoadingService = AudioLoadingService;
    exports.CompileResponse = CompileResponse;
    exports.GrowableAudioBuffer = GrowableAudioBuffer;
    exports.MIDIEvent = MIDIEvent;
    exports.MIDIManager = MIDIManager;
    exports.MusicTrace = MusicTrace;
    exports.Note = Note;
    exports.PythonRuntime = PythonRuntime;
    exports.Synthesizer = Synthesizer;
    exports.TraceEvent = TraceEvent;
    exports.TunePadAudio = TunePadAudio;
    exports.WaveformData = WaveformData;
    exports.clamp = clamp$1;
    exports.dBToGain = dBToGain;
    exports.dBToValue = dBToValue;
    exports.gainToValue = gainToValue;
    exports.gainTodB = gainTodB;
    exports.mix = mix;
    exports.toBool = toBool;
    exports.toDateTime = toDateTime;
    exports.toInt = toInt;
    exports.toNum = toNum;
    exports.toStr = toStr;
    exports.valueToGain = valueToGain;
    exports.valueTodB = valueTodB;
    exports.veloctyToGain = veloctyToGain;

    return exports;

})({}, Prism);
//# sourceMappingURL=tunepad.min.js.map
